# -*- coding: utf-8 -*-
"""9May.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DPKyKCvCrvVo9Z5bMXL6u34vLBRKLsbA
"""

!pip install gdown
import numpy as np
import pandas as pd
import time
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import gdown

# Download and load prediction data
fileid = "1RzD33rsPVs5WOox6VVGrcTQrBRLsTRLR"
url = f'https://drive.google.com/uc?id={fileid}'
output = 'vhs.zip'
gdown.download(url, output, quiet=False)
!unzip -o vhs.zip -d vhs

# Load appliance data
appliance_info = pd.read_excel("vhs/VHS/appliance_info.xlsx")

# Extract appliance details
appliance_names = appliance_info['Appliance'].tolist()
desired_start_times = appliance_info['Desired Start Time '].tolist()
active_durations = appliance_info['Active Duration'].tolist()
power_consumption = appliance_info['Power Consumption'].values
appliance_consumption = np.array(power_consumption)
N = len(appliance_names)  # Update the number of appliances
S = 24  # Number of time slots (24 hours in a day)

print(appliance_info)

# Load predicted solar generation data
predicted_generation_train = np.load("/content/vhs/VHS/train_predictions.npy")

# Reshape the array to have dimensions (86, 24) for 86 days and 24 hours per day
if predicted_generation_train.shape != (86, 24):
    predicted_generation_train = predicted_generation_train.reshape(86, 24)

# Verify the shape
print(f"Shape of predicted_generation_train after reshaping: {predicted_generation_train.shape}")

# Battery and power consumption constraints
Q_min = 0  # Minimum battery state of charge
Q_max = 500  # Maximum battery state of charge
Θ = 10 # Maximum power consumption threshold
Z_min = 0  # Minimum battery state of charge
Z_max = 100 # Maximum battery state of charge

# Generate appliance cost
#Generate the cost matrix based on appliance start times and variances
def generate_cost_matrix(N, S, appliance_info):
    appliance_cost = np.zeros((N, S))  # Initialize the cost matrix
    for i in range(N):
        mu = appliance_info["Desired Start Time "].iloc[i]  # Desired start time (1-indexed)
        sigma = appliance_info["Variance"].iloc[i]  # Variance for Gaussian distribution
        lower = appliance_info["Lower"].iloc[i]  # Lower bound for penalty
        upper = appliance_info["Upper"].iloc[i]  # Upper bound for penalty

        # Calculate the Gaussian distribution for the current appliance
        c = 1 - (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-0.5 * ((np.arange(S) - mu) / sigma) ** 2)

        # Apply penalty before the lower bound
        if lower != 0:
            c[:lower] = 100  # Apply penalty if the time is before the lower bound

        # Apply penalty after the upper bound
        if upper != 0:
            c[upper:] = 100  # Apply penalty if the time is after the upper bound

        appliance_cost[i, :] = c  # Store the cost for the current appliance

    return appliance_cost

import time
def fitness(solution, appliance_cost, spillover_slots, is_spillover_day, penalty=1000):
    # print the time taken
    start_time = time.time()  # Record start time
    """
    Compute the fitness of a solution, considering appliance costs, spillover logic,
    and penalties for appliances without valid activations.
    """
    total_cost = 0

    for n in range(solution.shape[0]):  # Loop over all appliances
        start_time = find_new_start_time(solution[n, :], spillover_slots[n, :], is_spillover_day)

        if start_time == -1:  # Double-check if the appliance is actually active before applying penalty
            if np.any(solution[n, :]) or (is_spillover_day and np.any(spillover_slots[n, :])):
                # The appliance is actually active, so no penalty should be applied
                print(f"Appliance {n}: Active but misidentified. No penalty applied.")
                start_time = np.argmax(solution[n, :])  # Assign valid start time
                total_cost += appliance_cost[n, start_time]
            else:
                # No activation found, so apply the penalty
                total_cost += penalty
                print(f"Appliance {n}: No valid activation found. Penalty applied: {penalty}")
        else:
            total_cost += appliance_cost[n, start_time]
            print(f"Appliance {n}: Start Time = {start_time}, Cost = {appliance_cost[n, start_time]}")


        print(f"Time taken: {time.time() - start_time} seconds")

    return total_cost

# Generate valid random solution with constraints
def generate_random_solution_with_constraints(battery_state_of_charge, predicted_generation):
    """
    Perform Random Search to find the best solution.

    Args:
    - battery_state_of_charge: Initial state of charge of the battery.
    - predicted_generation: Predicted energy generation data.

    Returns:
    - solution: The best solution found.
    """
    # Initialize a zero matrix for the schedule
    solution = np.zeros((N, 2*S), dtype=int)

    # Create a list of appliance indices and shuffle it
    appliances = list(range(N))
    np.random.shuffle(appliances)

    for n in appliances:
        valid = False
        for _ in range(10):
            # Randomly select a start time slot for the appliance
            start_slot = np.random.randint(0, S - active_durations[n] + 1)
            end_slot = start_slot + active_durations[n]

            # Check if the appliance can be scheduled in the selected time slot
            if np.sum(solution[n, start_slot:end_slot]) == 0:
                # Schedule the appliance
                solution[n, start_slot:end_slot] = 1

                # Temporary battery state of charge for validation
                temp_battery_state_of_charge = battery_state_of_charge
                valid = True

                # Validate the schedule against constraints
                for s in range(S):
                    # Update battery state of charge based on predicted generation
                    temp_battery_state_of_charge += np.clip(predicted_generation[s], Q_min, Q_max)

                    # Compute total power consumption at the time slot
                    total_power = np.sum(solution[:, s] * power_consumption)

                    # Check inverter and battery constraints
                    if total_power > Θ or total_power > temp_battery_state_of_charge:
                        valid = False
                        break

                    # Update battery state of charge after consumption
                    temp_battery_state_of_charge -= total_power
                    temp_battery_state_of_charge = np.clip(temp_battery_state_of_charge, Z_min, Z_max)

                if valid:
                    break
                else:
                    # If not valid, revert the changes
                    solution[n, start_slot:end_slot] = 0

    return solution


def prepare_next_day_initial_solution(previous_day_spillover, day):
    """
    Prepares the initial solution for the next day by carrying over the spillover from the previous day.
    The first S time slots are filled with the spillover from the previous day's solution.
    The remaining slots are initialized randomly.
    """
    # Initialize the next day’s solution with zeros
    solution = np.zeros((N, 2 * S), dtype=int)

    # Carry over the spillover from the previous day
    solution[:, :S] = previous_day_spillover[:, S:]  # Spillover from Day N-1 into Day N


    # Randomly initialize the remaining slots for each appliance
    for n in range(N):
        # Check remaining slots after spillover
        remaining_slots = S - np.sum(solution[n, :S])  # Available slots for the current day

        # If there are remaining active durations to schedule, handle them
        if remaining_slots > 0:
            # Random start time for remaining slots that are still 0 (not spillover)
            start_slot = np.random.randint(0, remaining_slots)
            end_slot = start_slot + active_durations[n]

            if end_slot <= remaining_slots:
                solution[n, start_slot:end_slot] = 1
            else:
                # Handle spillover into the next day
                solution[n, start_slot:S] = 1  # Fill up remaining slots in the current day
                spillover_duration = end_slot - S
                solution[n, S:S + spillover_duration] = 1  # Spillover into the next day

    return solution

def find_new_start_time(current_slots, spillover_slots, is_spillover_day):
    """Find the start time for new activations on the current day, considering spillover from the previous day."""
    if np.any(current_slots):  # Check if the appliance is active in the current day
        return np.argmax(current_slots)  # First active time slot

    if is_spillover_day and np.any(spillover_slots):  # Check if active in spillover period
        return np.argmax(spillover_slots)  # First active time slot in spillover

    return -1  # No activation found

# Visualization function for schedule with spillover
def visualize_schedule_with_spillover(best_solution, day, appliance_names):
    # Combine the current day's schedule and spillover into a single matrix for visualization
    combined_schedule = np.hstack([best_solution[:, :24], best_solution[:, 24:]])

    plt.figure(figsize=(16, 8))
    cmap = mcolors.ListedColormap(['aliceblue', 'darkblue'])
    bounds = [0, 1, 2]
    norm = mcolors.BoundaryNorm(bounds, cmap.N)
    plt.imshow(combined_schedule, aspect='auto', cmap=cmap, norm=norm, interpolation='nearest')
    plt.colorbar(label='Scheduled (1) / Not Scheduled (0)')
    plt.title(f'Schedule with Spillover for Day {day + 1}')
    plt.xlabel('Time Slot')
    plt.ylabel('Appliance')

    # Adjust y-axis to display appliance names
    plt.yticks(ticks=range(len(appliance_names)), labels=appliance_names)

    # Adjust x-axis to display time slots for both day and spillover
    plt.xticks(
        ticks=range(48),
        labels=[f"{i}:00" if i < 24 else f"{i - 24}:00 (spillover)" for i in range(48)],
        rotation=45
    )
    plt.grid(False)
    plt.tight_layout()
    plt.show()

def display_schedule(solution, day_index, previous_day_spillover):
    print(f"===== Optimized Day {day_index + 1} Schedule =====")
    for n in range(N):
        if day_index == 0:  # First day, only show current slots
            current_schedule = solution[n][:S]
            spillover_schedule = np.zeros(S)  # No spillover on the first day
            is_spillover_day = False
        else:  # Subsequent days, combine previous day's spillover and current schedule
            current_schedule = solution[n][:S]
            spillover_schedule = previous_day_spillover[n][S:]
            is_spillover_day = np.sum(spillover_schedule) > 0  # Determine if there was spillover

        # Calculate start time considering new activations after spillover
        start_time = find_new_start_time(current_schedule, spillover_schedule, is_spillover_day)

        print(f"Appliance {n + 1}: Start Time {start_time}, Duration {active_durations[n]}")
        print(f"Time Slots (first 24): {current_schedule}")
        print(f"Spillover into next day (next 24): {solution[n][S:]}")

 # Define the display function for the hourly breakdown
def display_hourly_breakdown(day, predicted_generation, best_solution, appliance_consumption, battery_state):
    print(f"\n===== Hourly Breakdown for Day {day + 1} =====")
    print("Hour   Generation (kWh)   Consumption (kWh)   Battery State (kWh) ")
    print("------------------------------------------------------------")

    for hour in range(48):
        generation = predicted_generation[hour]  # Predicted generation for this hour
        # Calculate total consumption based on the best solution
        consumption = np.sum(best_solution[:, hour] * appliance_consumption)  # Total consumption for this hour
        battery_state_for_hour = battery_state[hour]  # Battery state at this hour

        print(f"{hour:2}    {generation: .2f}             {consumption: .2f}             {battery_state_for_hour: .2f}")

    print("\n===== End of Hourly Breakdown =====\n")

"""This function implements a simulated annealing optimization algorithm for scheduling appliance usage over a 24-hour period, with spillover handling for appliances whose active durations may extend into the next day."""

def simulated_annealing_with_spillover(previous_day_spillover, day, initial_temperature, cooling_rate, max_iterations,
                                       battery_state_of_charge, predicted_generation, appliance_cost, appliance_consumption,
                                       active_durations, Q_min, Q_max, Z_min, Z_max, Θ):
    S = 24  # Total slots for scheduling (24 hours + 24 spillover slots)

    if day == 0:
        current_solution = generate_random_solution_with_constraints(battery_state_of_charge, predicted_generation)
    else:
        current_solution = prepare_next_day_initial_solution(previous_day_spillover, day)

    is_spillover_day = np.any(previous_day_spillover)
    spillover_slots = np.copy(previous_day_spillover)

    current_fitness = fitness(current_solution, appliance_cost, spillover_slots, is_spillover_day)
    best_solution = np.copy(current_solution)
    best_fitness = current_fitness
    temperature = initial_temperature

    appliances = list(range(len(appliance_cost)))

    # List to store fitness for plotting
    fitness_progression = [current_fitness]

    for iteration in range(max_iterations):
        print(f"Iteration {iteration + 1}")
        np.random.shuffle(appliances)  # Randomize appliance order

        for appliance_to_modify in appliances:
            new_solution = np.copy(current_solution)
            duration = active_durations[appliance_to_modify]

            start_slot = np.random.randint(0, S)
            end_slot = start_slot + duration

            # Reset schedule for this appliance
            new_solution[appliance_to_modify, :] = 0

            # Assign 1's to the selected time slots
            if end_slot <= S:
                new_solution[appliance_to_modify, start_slot:end_slot] = 1
            else:
                new_solution[appliance_to_modify, start_slot:S] = 1
                spillover_duration = end_slot - S
                new_solution[appliance_to_modify, S:S + spillover_duration] = 1  # Fill the next day's slots

            # Strict constraint checking
            valid_solution = True
            battery_state = float(battery_state_of_charge)
            for hour in range(2 * S):
                generation = np.clip(predicted_generation[hour], Q_min, Q_max)
                demand = np.sum(new_solution[:, hour] * appliance_consumption)

                if demand > Θ or demand > battery_state:
                    valid_solution = False
                    break

                battery_state += generation - demand
                if battery_state < Z_min or battery_state > Z_max:
                    valid_solution = False
                    break

            # Evaluate only valid solutions
            if valid_solution:
                new_fitness = fitness(new_solution, appliance_cost, spillover_slots, is_spillover_day)

                if new_fitness < best_fitness:
                    best_solution = np.copy(new_solution)
                    best_fitness = new_fitness

                acceptance_prob = np.exp((current_fitness - new_fitness) / temperature)
                if new_fitness < current_fitness or np.random.rand() < acceptance_prob:
                    current_solution = np.copy(new_solution)
                    current_fitness = new_fitness

                break  # Stop retry loop if valid solution found

        # Record fitness for plotting
        fitness_progression.append(best_fitness)

        # Cooling schedule
        temperature *= (1 / (1 + cooling_rate * (iteration + 1)))
        #if temperature < 1e-3:
          #  break

    # Plot the fitness progression
    plt.figure(figsize=(10, 6))
    plt.plot(fitness_progression, label="Best Fitness")
    plt.xlabel('Iteration')
    plt.ylabel('Fitness')
    plt.title('Fitness Progression Over Iterations')
    plt.grid(True)
    plt.legend()
    plt.show()

    return best_solution, best_fitness



"""# Run the simulation once for now"""

sa_results = []
total_days = 86
runs =  1 # Run the simulation once for now
best_fitness_values = []
sa_max_iterations = 10
cooling_rate = 0.95
initial_temperature = 100000
# Initialize battery state and spillover for the first day
initial_battery_state = 0
battery_state_of_charge_sa = initial_battery_state
previous_day_spillover_sa = np.zeros((N, 2 * S))

deviations_per_day = []  # Store deviation per appliance per day
percentage_per_day = []  # Store daily percentage of appliances with a cost of 100

def calculate_deviation(actual_start_time, desired_start_time):
    return actual_start_time - desired_start_time

for rpt in range(1, runs + 1):
    print(f"\n===== Simulating Run {rpt} =====")
    battery_state_of_charge_sa = initial_battery_state
    previous_day_spillover_sa = np.zeros((N, 2 * S))

    for day in range(total_days):
        print(f"Simulating Day {day + 1}")

        current_predicted_generation = predicted_generation_train[day % len(predicted_generation_train)]
        next_predicted_generation = predicted_generation_train[(day + 1) % len(predicted_generation_train)]
        predicted_generation_48h = np.concatenate([current_predicted_generation, next_predicted_generation])

        appliance_cost = generate_cost_matrix(N, S, appliance_info)
        start_time_sa = time.time()

        best_solution_sa, best_fitness_sa = simulated_annealing_with_spillover(
            previous_day_spillover_sa,
            day,
            initial_temperature,
            cooling_rate,
            sa_max_iterations,
            battery_state_of_charge_sa,
            predicted_generation_48h,
            appliance_cost,appliance_consumption, active_durations, Q_min, Q_max, Z_min, Z_max, Θ
        )

        end_time_sa = time.time()
        daily_deviation = []
        daily_costs = []
        appliances_with_100_cost = 0  # Initialize counter

        for n in range(N):
            desired_start_time = desired_start_times[n]
            actual_start_time = find_new_start_time(
                best_solution_sa[n, :S],
                best_solution_sa[n, S:],
                np.any(previous_day_spillover_sa)
            )
            deviation = calculate_deviation(actual_start_time, desired_start_time)
            appliance_total_cost = appliance_cost[n, actual_start_time]

            if appliance_total_cost == 100:
                appliances_with_100_cost += 1

            print(f"Appliance {n+1}: Desired Start = {desired_start_time}, Actual Start = {actual_start_time}, Deviation = {deviation}, Total Cost = {appliance_total_cost}")

            daily_deviation.append(deviation)
            daily_costs.append(appliance_total_cost)

        deviations_per_day.append(daily_deviation)
        percentage_per_day.append((appliances_with_100_cost / N) * 100)

        # Step 4: Initialize daily battery state
        battery_state_sa = np.zeros(48)

        # Step 5: Simulate hourly operations for the day
        for hour in range(48):
            generation = predicted_generation_48h[hour]
            required_consumption_sa = np.sum(best_solution_sa[:, hour] * appliance_consumption)
            available_energy_sa = battery_state_of_charge_sa if hour == 0 else battery_state_sa[hour - 1]
            actual_consumption_sa = min(required_consumption_sa, available_energy_sa)
            battery_state_sa[hour] = (battery_state_of_charge_sa + generation - actual_consumption_sa
                                      if hour == 0 else
                                      battery_state_sa[hour - 1] + generation - actual_consumption_sa)
            battery_state_sa[hour] = np.clip(battery_state_sa[hour], Z_min, Z_max)
            if actual_consumption_sa < required_consumption_sa:
                best_solution_sa[:, hour] = 0  # Disable usage if insufficient energy is available

        update_best_fitness_sa = fitness(best_solution_sa, appliance_cost, previous_day_spillover_sa, np.any(previous_day_spillover_sa), penalty=1000)
        sa_results.append([rpt, day + 1, "Simulated Annealing", best_fitness_sa, update_best_fitness_sa, end_time_sa - start_time_sa])
        display_schedule(best_solution_sa, day, previous_day_spillover_sa)
        visualize_schedule_with_spillover(best_solution_sa, day, appliance_names)
        print(f"Best Fitness: {best_fitness_sa}")
        print(f"Updated Fitness: {update_best_fitness_sa}")
        display_hourly_breakdown(day, predicted_generation_48h, best_solution_sa, appliance_consumption, battery_state_sa)
        previous_day_spillover_sa = best_solution_sa
        battery_state_of_charge_sa = battery_state_sa[23]

        plt.figure(figsize=(10, 6))
        plt.plot(range(24), predicted_generation_48h[:24], label='Predicted Generation (kWh)', color='blue')
        plt.plot(range(24), [np.sum(best_solution_sa[:, hour] * appliance_consumption) for hour in range(24)], label='Consumption (kWh)', color='green')
        plt.plot(range(24), battery_state_sa[:24], label='Battery State (kWh)', color='orange')
        plt.xlabel('Time (Hour of Day)')
        plt.ylabel('Energy (kWh)')
        plt.title(f'Day {day + 1} - Predicted Generation vs Consumption vs Battery State')
        plt.legend()
        plt.grid(True)
        plt.show()

    # === Stacked Bar Chart ===
    days = range(1, total_days + 1)
    percentage_not_cost_100 = [100 - p for p in percentage_per_day]

    plt.figure(figsize=(12, 6))
    plt.bar(days, percentage_per_day, color='salmon', edgecolor='black', label='Cost 100')
    plt.bar(days, percentage_not_cost_100, bottom=percentage_per_day, color='skyblue', edgecolor='black', label='Not Cost 100')


    # Labels & Titl
    plt.xlabel('Day')
    plt.ylabel('Percentage of Appliances')
    plt.title('Percentage of Appliances with Cost 100 vs Not Cost 100 Over Days')
    plt.xticks(range(1, total_days + 1, max(1, total_days // 10)))  # Adjust x-axis ticks dynamically
    plt.yticks(np.arange(0, 110, 10))  # Y-axis from 0 to 100 in steps of 10
    plt.legend()
    plt.grid(axis='y', linestyle='--', alpha=0.7)

    plt.show()



    sa_results_df = pd.DataFrame(sa_results, columns=["Run", "Day", "Method", "Best Fitness", "Updated Fitness", "Execution Time (s)"])
    deviations_df = pd.DataFrame(deviations_per_day, columns=[f"Appliance {i+1}" for i in range(N)])

"""run with the update of cooling"""

def simulated_annealing_with_spillover(previous_day_spillover, day, initial_temperature, cooling_rate, max_iterations,
                                       battery_state_of_charge, predicted_generation, appliance_cost, appliance_consumption,
                                       active_durations, Q_min, Q_max, Z_min, Z_max, Θ):
    S = 24  # Total slots for scheduling (24 hours + 24 spillover slots)

    if day == 0:
        current_solution = generate_random_solution_with_constraints(battery_state_of_charge, predicted_generation)
    else:
        current_solution = prepare_next_day_initial_solution(previous_day_spillover, day)

    is_spillover_day = np.any(previous_day_spillover)
    spillover_slots = np.copy(previous_day_spillover)

    current_fitness = fitness(current_solution, appliance_cost, spillover_slots, is_spillover_day)
    best_solution = np.copy(current_solution)
    best_fitness = current_fitness
    temperature = initial_temperature

    appliances = list(range(len(appliance_cost)))

    # List to store fitness for plotting
    fitness_progression = [current_fitness]

    for iteration in range(max_iterations):
        print(f"Iteration {iteration + 1}")
        np.random.shuffle(appliances)  # Randomize appliance order

        for appliance_to_modify in appliances:
            new_solution = np.copy(current_solution)
            duration = active_durations[appliance_to_modify]

            start_slot = np.random.randint(0, S)
            end_slot = start_slot + duration

            # Reset schedule for this appliance
            new_solution[appliance_to_modify, :] = 0

            # Assign 1's to the selected time slots
            if end_slot <= S:
                new_solution[appliance_to_modify, start_slot:end_slot] = 1
            else:
                new_solution[appliance_to_modify, start_slot:S] = 1
                spillover_duration = end_slot - S
                new_solution[appliance_to_modify, S:S + spillover_duration] = 1  # Fill the next day's slots

            # Strict constraint checking
            # Strict constraint checking
            valid_solution = True
            battery_state = float(battery_state_of_charge)
            for hour in range(2 * S):
                generation = np.clip(predicted_generation[hour], Q_min, Q_max)
                demand = np.sum(new_solution[:, hour] * appliance_consumption)

                if demand > Θ or demand > battery_state:
                    valid_solution = False
                    break

                battery_state += generation - demand
                if battery_state < Z_min or battery_state > Z_max:
                    valid_solution = False
                    break


            # Evaluate only valid solutions
            if valid_solution:
                new_fitness = fitness(new_solution, appliance_cost, spillover_slots, is_spillover_day)

                if new_fitness < best_fitness:
                    best_solution = np.copy(new_solution)
                    best_fitness = new_fitness

                acceptance_prob = np.exp((current_fitness - new_fitness) / temperature)
                if new_fitness < current_fitness or np.random.rand() < acceptance_prob:
                    current_solution = np.copy(new_solution)
                    current_fitness = new_fitness

                break  # Stop retry loop if valid solution found

        # Record fitness for plotting
        fitness_progression.append(best_fitness)

        # Cooling schedule
        #temperature *= (1 / (1 + cooling_rate * (iteration + 1)))
        temperature *= cooling_rate  # geometric cooling
        #if temperature < 1e-3:
          #  break

    # Plot the fitness progression
    plt.figure(figsize=(10, 6))
    plt.plot(fitness_progression, label="Best Fitness")
    plt.xlabel('Iteration')
    plt.ylabel('Fitness')
    plt.title('Fitness Progression Over Iterations')
    plt.grid(True)
    plt.legend()
    plt.show()

    return best_solution, best_fitness

def generate_random_solution_with_constraints(battery_state_of_charge, predicted_generation):
    """
    Generate a valid initial schedule satisfying battery and inverter constraints for 2S time slots.
    """
    solution = np.zeros((N, 2 * S), dtype=int)
    appliances = list(range(N))
    np.random.shuffle(appliances)

    for n in appliances:
        valid = False
        attempts = 0

        while not valid and attempts < 20:
            attempts += 1
            duration = active_durations[n]
            start_slot = np.random.randint(0, S)
            end_slot = start_slot + duration

            # Reset appliance schedule
            solution[n, :] = 0
            solution[n, start_slot:end_slot] = 1

            # Constraint check across 2S
            valid = True
            battery_state = float(battery_state_of_charge)

            for hour in range(2 * S):
                generation = np.clip(predicted_generation[hour], Q_min, Q_max)
                demand = np.sum(solution[:, hour] * power_consumption)

                if demand > Θ or demand > battery_state:
                    valid = False
                    break

                battery_state += generation - demand
                if battery_state < Z_min or battery_state > Z_max:
                    valid = False
                    break

        if not valid:
            # If failed after all retries, leave appliance unscheduled or raise warning
            print(f"Warning: Could not find valid initial schedule for appliance {n}")

    return solution

sa_results = []
total_days = 86
runs =  1 # Run the simulation once for now
best_fitness_values = []
sa_max_iterations = 100
cooling_rate = 0.995
initial_temperature = 100000
# Initialize battery state and spillover for the first day
initial_battery_state = 0
battery_state_of_charge_sa = initial_battery_state
previous_day_spillover_sa = np.zeros((N, 2 * S))

deviations_per_day = []  # Store deviation per appliance per day
percentage_per_day = []  # Store daily percentage of appliances with a cost of 100

def calculate_deviation(actual_start_time, desired_start_time):
    return actual_start_time - desired_start_time

for rpt in range(1, runs + 1):
    print(f"\n===== Simulating Run {rpt} =====")
    battery_state_of_charge_sa = initial_battery_state
    previous_day_spillover_sa = np.zeros((N, 2 * S))

    for day in range(total_days):
        print(f"Simulating Day {day + 1}")

        current_predicted_generation = predicted_generation_train[day % len(predicted_generation_train)]
        next_predicted_generation = predicted_generation_train[(day + 1) % len(predicted_generation_train)]
        predicted_generation_48h = np.concatenate([current_predicted_generation, next_predicted_generation])

        appliance_cost = generate_cost_matrix(N, S, appliance_info)
        start_time_sa = time.time()

        best_solution_sa, best_fitness_sa = simulated_annealing_with_spillover(
            previous_day_spillover_sa,
            day,
            initial_temperature,
            cooling_rate,
            sa_max_iterations,
            battery_state_of_charge_sa,
            predicted_generation_48h,
            appliance_cost,appliance_consumption, active_durations, Q_min, Q_max, Z_min, Z_max, Θ
        )

        end_time_sa = time.time()
        daily_deviation = []
        daily_costs = []
        appliances_with_100_cost = 0  # Initialize counter

        for n in range(N):
            desired_start_time = desired_start_times[n]
            actual_start_time = find_new_start_time(
                best_solution_sa[n, :S],
                best_solution_sa[n, S:],
                np.any(previous_day_spillover_sa)
            )
            deviation = calculate_deviation(actual_start_time, desired_start_time)
            appliance_total_cost = appliance_cost[n, actual_start_time]

            if appliance_total_cost == 100:
                appliances_with_100_cost += 1

            print(f"Appliance {n+1}: Desired Start = {desired_start_time}, Actual Start = {actual_start_time}, Deviation = {deviation}, Total Cost = {appliance_total_cost}")

            daily_deviation.append(deviation)
            daily_costs.append(appliance_total_cost)

        deviations_per_day.append(daily_deviation)
        percentage_per_day.append((appliances_with_100_cost / N) * 100)

        # Step 4: Initialize daily battery state
        battery_state_sa = np.zeros(48)

        # Step 5: Simulate hourly operations for the day
        for hour in range(48):
            generation = predicted_generation_48h[hour]
            required_consumption_sa = np.sum(best_solution_sa[:, hour] * appliance_consumption)
            available_energy_sa = battery_state_of_charge_sa if hour == 0 else battery_state_sa[hour - 1]
            actual_consumption_sa = min(required_consumption_sa, available_energy_sa)
            battery_state_sa[hour] = (battery_state_of_charge_sa + generation - actual_consumption_sa
                                      if hour == 0 else
                                      battery_state_sa[hour - 1] + generation - actual_consumption_sa)
            battery_state_sa[hour] = np.clip(battery_state_sa[hour], Z_min, Z_max)
            if actual_consumption_sa < required_consumption_sa:
                best_solution_sa[:, hour] = 0  # Disable usage if insufficient energy is available

        update_best_fitness_sa = fitness(best_solution_sa, appliance_cost, previous_day_spillover_sa, np.any(previous_day_spillover_sa), penalty=1000)
        sa_results.append([rpt, day + 1, "Simulated Annealing", best_fitness_sa, update_best_fitness_sa, end_time_sa - start_time_sa])
        display_schedule(best_solution_sa, day, previous_day_spillover_sa)
        visualize_schedule_with_spillover(best_solution_sa, day, appliance_names)
        print(f"Best Fitness: {best_fitness_sa}")
        print(f"Updated Fitness: {update_best_fitness_sa}")
        display_hourly_breakdown(day, predicted_generation_48h, best_solution_sa, appliance_consumption, battery_state_sa)
        previous_day_spillover_sa = best_solution_sa
        battery_state_of_charge_sa = battery_state_sa[23]

        plt.figure(figsize=(10, 6))
        plt.plot(range(24), predicted_generation_48h[:24], label='Predicted Generation (kWh)', color='blue')
        plt.plot(range(24), [np.sum(best_solution_sa[:, hour] * appliance_consumption) for hour in range(24)], label='Consumption (kWh)', color='green')
        plt.plot(range(24), battery_state_sa[:24], label='Battery State (kWh)', color='orange')
        plt.xlabel('Time (Hour of Day)')
        plt.ylabel('Energy (kWh)')
        plt.title(f'Day {day + 1} - Predicted Generation vs Consumption vs Battery State')
        plt.legend()
        plt.grid(True)
        plt.show()

    # === Stacked Bar Chart ===
    days = range(1, total_days + 1)
    percentage_not_cost_100 = [100 - p for p in percentage_per_day]

    plt.figure(figsize=(12, 6))
    plt.bar(days, percentage_per_day, color='salmon', edgecolor='black', label='Cost 100')
    plt.bar(days, percentage_not_cost_100, bottom=percentage_per_day, color='skyblue', edgecolor='black', label='Not Cost 100')


    # Labels & Titl
    plt.xlabel('Day')
    plt.ylabel('Percentage of Appliances')
    plt.title('Percentage of Appliances with Cost 100 vs Not Cost 100 Over Days')
    plt.xticks(range(1, total_days + 1, max(1, total_days // 10)))  # Adjust x-axis ticks dynamically
    plt.yticks(np.arange(0, 110, 10))  # Y-axis from 0 to 100 in steps of 10
    plt.legend()
    plt.grid(axis='y', linestyle='--', alpha=0.7)

    plt.show()



    sa_results_df = pd.DataFrame(sa_results, columns=["Run", "Day", "Method", "Best Fitness", "Updated Fitness", "Execution Time (s)"])
    deviations_df = pd.DataFrame(deviations_per_day, columns=[f"Appliance {i+1}" for i in range(N)])

# Group SA results by 'Run' and calculate statistics
sa_summary = sa_results_df.groupby("Run").agg({
    "Day": "count",
    "Best Fitness": ["mean", "std", "min", "max", "median"],
    "Updated Fitness" : ["mean", "std", "min", "max", "median"],
    "Execution Time (s)": "sum"
})

# Rename columns for clarity
sa_summary.columns = [
    "Days Count",
    "Best Fitness Mean", "Best Fitness Std", "Best Fitness Min", "Best Fitness Max", "Best Fitness Median",
    "Updated Fitness Mean", "Updated Fitness Std", "Updated Fitness Min", "Updated Fitness Max", "Updated Fitness Median",
    "Total Execution Time (s)"
]
sa_summary.reset_index(inplace=True)



print("\n=====  Simulated Annealing (SA) Grouped Summary by Run =====")
print(sa_summary)

# Extract fitness values from SA results
best_fitness_sa = sa_results_df["Best Fitness"].tolist()
updated_fitness_sa = sa_results_df["Updated Fitness"].tolist()

# Compute Optimal Fitness (Sum of minimum costs per appliance)
optimal_fitness = sum(np.min(appliance_cost, axis=1))  # Smallest cost per appliance

# Generate Plot
plt.figure(figsize=(12, 6))
days = range(1, len(best_fitness_sa) + 1)


# Plot SA results
plt.plot(days, best_fitness_sa, label="Best Fitness (SA)", marker="d", linestyle="-", color="green")
#plt.plot(days, updated_fitness_sa, label="Updated Fitness (SA)", marker="^", linestyle="--", color="lime")

# Plot Optimal Fitness as a horizontal line
plt.axhline(y=optimal_fitness, color="red", linestyle="--", label="Optimal Fitness")

# Labels and Title
plt.xlabel("Day")
plt.ylabel("Fitness Value")
plt.title("Comparison of SA Fitness vs. Optimal Fitness Over Days")
plt.legend()
plt.grid(True)

# Show plot
plt.show()

sa_results = []
total_days = 86
runs =  1 # Run the simulation once for now
best_fitness_values = []
sa_max_iterations = 100
cooling_rate = 0.995
initial_temperature = 100000
# Initialize battery state and spillover for the first day
initial_battery_state = 0
battery_state_of_charge_sa = initial_battery_state
previous_day_spillover_sa = np.zeros((N, 2 * S))

deviations_per_day = []  # Store deviation per appliance per day
percentage_per_day = []  # Store daily percentage of appliances with a cost of 100

def calculate_deviation(actual_start_time, desired_start_time):
    return actual_start_time - desired_start_time

for rpt in range(1, runs + 1):
    print(f"\n===== Simulating Run {rpt} =====")
    battery_state_of_charge_sa = initial_battery_state
    previous_day_spillover_sa = np.zeros((N, 2 * S))

    for day in range(total_days):
        print(f"Simulating Day {day + 1}")

        current_predicted_generation = predicted_generation_train[day % len(predicted_generation_train)]
        next_predicted_generation = predicted_generation_train[(day + 1) % len(predicted_generation_train)]
        predicted_generation_48h = np.concatenate([current_predicted_generation, next_predicted_generation])

        appliance_cost = generate_cost_matrix(N, S, appliance_info)
        start_time_sa = time.time()

        best_solution_sa, best_fitness_sa = simulated_annealing_with_spillover(
            previous_day_spillover_sa,
            day,
            initial_temperature,
            cooling_rate,
            sa_max_iterations,
            battery_state_of_charge_sa,
            predicted_generation_48h,
            appliance_cost,appliance_consumption, active_durations, Q_min, Q_max, Z_min, Z_max, Θ
        )

        end_time_sa = time.time()
        daily_deviation = []
        daily_costs = []
        appliances_with_100_cost = 0  # Initialize counter

        for n in range(N):
            desired_start_time = desired_start_times[n]
            actual_start_time = find_new_start_time(
                best_solution_sa[n, :S],
                best_solution_sa[n, S:],
                np.any(previous_day_spillover_sa)
            )
            deviation = calculate_deviation(actual_start_time, desired_start_time)
            appliance_total_cost = appliance_cost[n, actual_start_time]

            if appliance_total_cost == 100:
                appliances_with_100_cost += 1

            print(f"Appliance {n+1}: Desired Start = {desired_start_time}, Actual Start = {actual_start_time}, Deviation = {deviation}, Total Cost = {appliance_total_cost}")

            daily_deviation.append(deviation)
            daily_costs.append(appliance_total_cost)

        deviations_per_day.append(daily_deviation)
        percentage_per_day.append((appliances_with_100_cost / N) * 100)

        # Step 4: Initialize daily battery state
        battery_state_sa = np.zeros(48)

        # Step 5: Simulate hourly operations for the day
        for hour in range(48):
            generation = predicted_generation_48h[hour]
            required_consumption_sa = np.sum(best_solution_sa[:, hour] * appliance_consumption)
            available_energy_sa = battery_state_of_charge_sa if hour == 0 else battery_state_sa[hour - 1]
            actual_consumption_sa = min(required_consumption_sa, available_energy_sa)
            battery_state_sa[hour] = (battery_state_of_charge_sa + generation - actual_consumption_sa
                                      if hour == 0 else
                                      battery_state_sa[hour - 1] + generation - actual_consumption_sa)
            battery_state_sa[hour] = np.clip(battery_state_sa[hour], Z_min, Z_max)
            if actual_consumption_sa < required_consumption_sa:
                best_solution_sa[:, hour] = 0  # Disable usage if insufficient energy is available

        update_best_fitness_sa = fitness(best_solution_sa, appliance_cost, previous_day_spillover_sa, np.any(previous_day_spillover_sa), penalty=1000)
        sa_results.append([rpt, day + 1, "Simulated Annealing", best_fitness_sa, update_best_fitness_sa, end_time_sa - start_time_sa])
        display_schedule(best_solution_sa, day, previous_day_spillover_sa)
        visualize_schedule_with_spillover(best_solution_sa, day, appliance_names)
        print(f"Best Fitness: {best_fitness_sa}")
        print(f"Updated Fitness: {update_best_fitness_sa}")
        display_hourly_breakdown(day, predicted_generation_48h, best_solution_sa, appliance_consumption, battery_state_sa)
        previous_day_spillover_sa = best_solution_sa
        battery_state_of_charge_sa = battery_state_sa[23]

        plt.figure(figsize=(10, 6))
        plt.plot(range(24), predicted_generation_48h[:24], label='Predicted Generation (kWh)', color='blue')
        plt.plot(range(24), [np.sum(best_solution_sa[:, hour] * appliance_consumption) for hour in range(24)], label='Consumption (kWh)', color='green')
        plt.plot(range(24), battery_state_sa[:24], label='Battery State (kWh)', color='orange')
        plt.xlabel('Time (Hour of Day)')
        plt.ylabel('Energy (kWh)')
        plt.title(f'Day {day + 1} - Predicted Generation vs Consumption vs Battery State')
        plt.legend()
        plt.grid(True)
        plt.show()

    # === Stacked Bar Chart ===
    days = range(1, total_days + 1)
    percentage_not_cost_100 = [100 - p for p in percentage_per_day]

    plt.figure(figsize=(12, 6))
    plt.bar(days, percentage_per_day, color='salmon', edgecolor='black', label='Cost 100')
    plt.bar(days, percentage_not_cost_100, bottom=percentage_per_day, color='skyblue', edgecolor='black', label='Not Cost 100')


    # Labels & Titl
    plt.xlabel('Day')
    plt.ylabel('Percentage of Appliances')
    plt.title('Percentage of Appliances with Cost 100 vs Not Cost 100 Over Days')
    plt.xticks(range(1, total_days + 1, max(1, total_days // 10)))  # Adjust x-axis ticks dynamically
    plt.yticks(np.arange(0, 110, 10))  # Y-axis from 0 to 100 in steps of 10
    plt.legend()
    plt.grid(axis='y', linestyle='--', alpha=0.7)

    plt.show()



    sa_results_df = pd.DataFrame(sa_results, columns=["Run", "Day", "Method", "Best Fitness", "Updated Fitness", "Execution Time (s)"])
    deviations_df = pd.DataFrame(deviations_per_day, columns=[f"Appliance {i+1}" for i in range(N)])

# Group SA results by 'Run' and calculate statistics
sa_summary = sa_results_df.groupby("Run").agg({
    "Day": "count",
    "Best Fitness": ["mean", "std", "min", "max", "median"],
    "Updated Fitness" : ["mean", "std", "min", "max", "median"],
    "Execution Time (s)": "sum"
})

# Rename columns for clarity
sa_summary.columns = [
    "Days Count",
    "Best Fitness Mean", "Best Fitness Std", "Best Fitness Min", "Best Fitness Max", "Best Fitness Median",
    "Updated Fitness Mean", "Updated Fitness Std", "Updated Fitness Min", "Updated Fitness Max", "Updated Fitness Median",
    "Total Execution Time (s)"
]
sa_summary.reset_index(inplace=True)



print("\n=====  Simulated Annealing (SA) Grouped Summary by Run =====")
print(sa_summary)

# Extract relevant columns (Run, Day, Best Fitness, and Updated Fitness)
fitness_comparison = sa_results_df[["Run", "Day", "Best Fitness", "Updated Fitness"]]

# Optionally, reset the index for a cleaner display
fitness_comparison.reset_index(drop=True, inplace=True)

# Display the comparison table
print("\n===== Best Fitness vs Updated Fitness per Day =====")
print(fitness_comparison)

# Save the DataFrame to an Excel file
fitness_comparison.to_excel("fitness_comparison_SA.xlsx", index=False)

print(" Fitness comparison saved to 'fitness_comparison_SA.xlsx'")

# Group SA results by 'Run' and calculate statistics
sa_summary = sa_results_df.groupby("Run").agg({
    "Day": "count",
    "Best Fitness": ["mean", "std", "min", "max", "median"],
    "Updated Fitness" : ["mean", "std", "min", "max", "median"],
    "Execution Time (s)": "sum"
})

# Rename columns for clarity
sa_summary.columns = [
    "Days Count",
    "Best Fitness Mean", "Best Fitness Std", "Best Fitness Min", "Best Fitness Max", "Best Fitness Median",
    "Updated Fitness Mean", "Updated Fitness Std", "Updated Fitness Min", "Updated Fitness Max", "Updated Fitness Median",
    "Total Execution Time (s)"
]
sa_summary.reset_index(inplace=True)



print("\n=====  Simulated Annealing (SA) Grouped Summary by Run =====")
print(sa_summary)

# Extract relevant columns (Run, Day, Best Fitness, and Updated Fitness)
fitness_comparison = sa_results_df[["Run", "Day", "Best Fitness", "Updated Fitness"]]

# Optionally, reset the index for a cleaner display
fitness_comparison.reset_index(drop=True, inplace=True)

# Display the comparison table
print("\n===== Best Fitness vs Updated Fitness per Day =====")
print(fitness_comparison)

# Save the DataFrame to an Excel file
fitness_comparison.to_excel("fitness_comparison_SA.xlsx", index=False)

print(" Fitness comparison saved to 'fitness_comparison_SA.xlsx'")

# Extract fitness values from SA results
best_fitness_sa = sa_results_df["Best Fitness"].tolist()
updated_fitness_sa = sa_results_df["Updated Fitness"].tolist()

# Compute Optimal Fitness (Sum of minimum costs per appliance)
optimal_fitness = sum(np.min(appliance_cost, axis=1))  # Smallest cost per appliance

# Generate Plot
plt.figure(figsize=(12, 6))
days = range(1, len(best_fitness_sa) + 1)


# Plot SA results
plt.plot(days, best_fitness_sa, label="Best Fitness (SA)", marker="d", linestyle="-", color="green")
#plt.plot(days, updated_fitness_sa, label="Updated Fitness (SA)", marker="^", linestyle="--", color="lime")

# Plot Optimal Fitness as a horizontal line
plt.axhline(y=optimal_fitness, color="red", linestyle="--", label="Optimal Fitness")

# Labels and Title
plt.xlabel("Day")
plt.ylabel("Fitness Value")
plt.title("Comparison of SA Fitness vs. Optimal Fitness Over Days")
plt.legend()
plt.grid(True)

# Show plot
plt.show()

# Extract fitness values from SA results
best_fitness_sa = sa_results_df["Best Fitness"].tolist()
updated_fitness_sa = sa_results_df["Updated Fitness"].tolist()

# Compute Optimal Fitness (Sum of minimum costs per appliance)
optimal_fitness = sum(np.min(appliance_cost, axis=1))  # Smallest cost per appliance

# Generate Plot
plt.figure(figsize=(12, 6))
days = range(1, len(best_fitness_sa) + 1)


# Plot SA results
plt.plot(days, best_fitness_sa, label="Best Fitness (SA)", marker="d", linestyle="-", color="green")
#plt.plot(days, updated_fitness_sa, label="Updated Fitness (SA)", marker="^", linestyle="--", color="lime")

# Plot Optimal Fitness as a horizontal line
plt.axhline(y=optimal_fitness, color="red", linestyle="--", label="Optimal Fitness")

# Labels and Title
plt.xlabel("Day")
plt.ylabel("Fitness Value")
plt.title("Comparison of SA Fitness vs. Optimal Fitness Over Days")
plt.legend()
plt.grid(True)

# Show plot
plt.show()

def simulated_annealing_with_spillover(previous_day_spillover, day, initial_temperature, cooling_rate, max_iterations,
                                       battery_state_of_charge, predicted_generation, appliance_cost, appliance_consumption,
                                       active_durations, Q_min, Q_max, Z_min, Z_max, Θ):
    S = 24  # Total slots for scheduling (24 hours + 24 spillover slots)

    if day == 0:
        current_solution = generate_random_solution_with_constraints(battery_state_of_charge, predicted_generation)
    else:
        current_solution = prepare_next_day_initial_solution(previous_day_spillover, day)

    is_spillover_day = np.any(previous_day_spillover)
    spillover_slots = np.copy(previous_day_spillover)

    current_fitness = fitness(current_solution, appliance_cost, spillover_slots, is_spillover_day)
    best_solution = np.copy(current_solution)
    best_fitness = current_fitness
    temperature = initial_temperature

     #List to store fitness for plotting
    fitness_progression = [current_fitness]


    appliances = list(range(len(appliance_cost)))

    for iteration in range(max_iterations):
        np.random.shuffle(appliances)  # Randomize appliance order for this iteration

        for appliance_to_modify in appliances:
            new_solution = np.copy(current_solution)
            duration = active_durations[appliance_to_modify]

            # Avoid high-cost slots for appliances 5 & 6
            if appliance_to_modify in [5, 6]:
                possible_slots = np.where(appliance_cost[appliance_to_modify, :24] < 100)[0]
                if len(possible_slots) > 0:
                    start_slot = np.random.choice(possible_slots)
                else:
                    start_slot = np.random.randint(0, S)
            else:
                start_slot = np.random.randint(0, S)

            end_slot = start_slot + duration

            new_solution[appliance_to_modify, :] = 0  # Reset schedule

            if end_slot <= S:
                new_solution[appliance_to_modify, start_slot:end_slot] = 1
            else:
                new_solution[appliance_to_modify, start_slot:S] = 1
                spillover_duration = end_slot - S
                new_solution[appliance_to_modify, S:S + spillover_duration] = 1  # Fill next day's slots

            # Validate constraints over the scheduling horizon
            valid_solution = True
            temp_battery_state_of_charge = battery_state_of_charge


            for hour in range(2 * S):
                temp_battery_state_of_charge += np.clip(predicted_generation[hour], Q_min, Q_max)
                total_power = np.sum(new_solution[:, hour] * appliance_consumption)
                temp_battery_state_of_charge -= total_power
                temp_battery_state_of_charge = np.clip(temp_battery_state_of_charge, Z_min, Z_max)


                if total_power > Θ or total_power > temp_battery_state_of_charge:
                    valid_solution = False
                    break


            # Evaluate the new solution only if valid
            if valid_solution:
                new_fitness = fitness(new_solution, appliance_cost, spillover_slots, is_spillover_day)

                if new_fitness < best_fitness:
                    best_solution = np.copy(new_solution)
                    best_fitness = new_fitness

                acceptance_prob = np.exp((current_fitness - new_fitness) / temperature)
                if new_fitness < current_fitness or np.random.rand() < acceptance_prob:
                    current_solution = np.copy(new_solution)
                    current_fitness = new_fitness
        # Record fitness for plotting
        fitness_progression.append(best_fitness)

        # Cooling schedule (ensuring gradual cooling)
        #temperature *= (1 / (1 + cooling_rate * (iteration + 1)))
        temperature *= cooling_rate  # geometric cooling
       # if temperature < 1e-3:
           # break

    # Plot the fitness progression
    plt.figure(figsize=(10, 6))
    plt.plot(fitness_progression, label="Best Fitness")
    plt.xlabel('Iteration')
    plt.ylabel('Fitness')
    plt.title('Fitness Progression Over Iterations')
    plt.grid(True)
    plt.legend()
    plt.show()

    return best_solution, best_fitness

sa_results = []
total_days = 86
runs =  1 # Run the simulation once for now
best_fitness_values = []
sa_max_iterations = 100
cooling_rate = 0.995
initial_temperature = 100000
# Initialize battery state and spillover for the first day
initial_battery_state = 0
battery_state_of_charge_sa = initial_battery_state
previous_day_spillover_sa = np.zeros((N, 2 * S))

deviations_per_day = []  # Store deviation per appliance per day
percentage_per_day = []  # Store daily percentage of appliances with a cost of 100

def calculate_deviation(actual_start_time, desired_start_time):
    return actual_start_time - desired_start_time

for rpt in range(1, runs + 1):
    print(f"\n===== Simulating Run {rpt} =====")
    battery_state_of_charge_sa = initial_battery_state
    previous_day_spillover_sa = np.zeros((N, 2 * S))

    for day in range(total_days):
        print(f"Simulating Day {day + 1}")

        current_predicted_generation = predicted_generation_train[day % len(predicted_generation_train)]
        next_predicted_generation = predicted_generation_train[(day + 1) % len(predicted_generation_train)]
        predicted_generation_48h = np.concatenate([current_predicted_generation, next_predicted_generation])

        appliance_cost = generate_cost_matrix(N, S, appliance_info)
        start_time_sa = time.time()

        best_solution_sa, best_fitness_sa = simulated_annealing_with_spillover(
            previous_day_spillover_sa,
            day,
            initial_temperature,
            cooling_rate,
            sa_max_iterations,
            battery_state_of_charge_sa,
            predicted_generation_48h,
            appliance_cost,appliance_consumption, active_durations, Q_min, Q_max, Z_min, Z_max, Θ
        )

        end_time_sa = time.time()
        daily_deviation = []
        daily_costs = []
        appliances_with_100_cost = 0  # Initialize counter

        for n in range(N):
            desired_start_time = desired_start_times[n]
            actual_start_time = find_new_start_time(
                best_solution_sa[n, :S],
                best_solution_sa[n, S:],
                np.any(previous_day_spillover_sa)
            )
            deviation = calculate_deviation(actual_start_time, desired_start_time)
            appliance_total_cost = appliance_cost[n, actual_start_time]

            if appliance_total_cost == 100:
                appliances_with_100_cost += 1

            print(f"Appliance {n+1}: Desired Start = {desired_start_time}, Actual Start = {actual_start_time}, Deviation = {deviation}, Total Cost = {appliance_total_cost}")

            daily_deviation.append(deviation)
            daily_costs.append(appliance_total_cost)

        deviations_per_day.append(daily_deviation)
        percentage_per_day.append((appliances_with_100_cost / N) * 100)

        # Step 4: Initialize daily battery state
        battery_state_sa = np.zeros(48)

        # Step 5: Simulate hourly operations for the day
        for hour in range(48):
            generation = predicted_generation_48h[hour]
            required_consumption_sa = np.sum(best_solution_sa[:, hour] * appliance_consumption)
            available_energy_sa = battery_state_of_charge_sa if hour == 0 else battery_state_sa[hour - 1]
            actual_consumption_sa = min(required_consumption_sa, available_energy_sa)
            battery_state_sa[hour] = (battery_state_of_charge_sa + generation - actual_consumption_sa
                                      if hour == 0 else
                                      battery_state_sa[hour - 1] + generation - actual_consumption_sa)
            battery_state_sa[hour] = np.clip(battery_state_sa[hour], Z_min, Z_max)
            if actual_consumption_sa < required_consumption_sa:
                best_solution_sa[:, hour] = 0  # Disable usage if insufficient energy is available

        update_best_fitness_sa = fitness(best_solution_sa, appliance_cost, previous_day_spillover_sa, np.any(previous_day_spillover_sa), penalty=1000)
        sa_results.append([rpt, day + 1, "Simulated Annealing", best_fitness_sa, update_best_fitness_sa, end_time_sa - start_time_sa])
        display_schedule(best_solution_sa, day, previous_day_spillover_sa)
        visualize_schedule_with_spillover(best_solution_sa, day, appliance_names)
        print(f"Best Fitness: {best_fitness_sa}")
        print(f"Updated Fitness: {update_best_fitness_sa}")
        display_hourly_breakdown(day, predicted_generation_48h, best_solution_sa, appliance_consumption, battery_state_sa)
        previous_day_spillover_sa = best_solution_sa
        battery_state_of_charge_sa = battery_state_sa[23]

        plt.figure(figsize=(10, 6))
        plt.plot(range(24), predicted_generation_48h[:24], label='Predicted Generation (kWh)', color='blue')
        plt.plot(range(24), [np.sum(best_solution_sa[:, hour] * appliance_consumption) for hour in range(24)], label='Consumption (kWh)', color='green')
        plt.plot(range(24), battery_state_sa[:24], label='Battery State (kWh)', color='orange')
        plt.xlabel('Time (Hour of Day)')
        plt.ylabel('Energy (kWh)')
        plt.title(f'Day {day + 1} - Predicted Generation vs Consumption vs Battery State')
        plt.legend()
        plt.grid(True)
        plt.show()

    # === Stacked Bar Chart ===
    days = range(1, total_days + 1)
    percentage_not_cost_100 = [100 - p for p in percentage_per_day]

    plt.figure(figsize=(12, 6))
    plt.bar(days, percentage_per_day, color='salmon', edgecolor='black', label='Cost 100')
    plt.bar(days, percentage_not_cost_100, bottom=percentage_per_day, color='skyblue', edgecolor='black', label='Not Cost 100')


    # Labels & Titl
    plt.xlabel('Day')
    plt.ylabel('Percentage of Appliances')
    plt.title('Percentage of Appliances with Cost 100 vs Not Cost 100 Over Days')
    plt.xticks(range(1, total_days + 1, max(1, total_days // 10)))  # Adjust x-axis ticks dynamically
    plt.yticks(np.arange(0, 110, 10))  # Y-axis from 0 to 100 in steps of 10
    plt.legend()
    plt.grid(axis='y', linestyle='--', alpha=0.7)

    plt.show()



    sa_results_df = pd.DataFrame(sa_results, columns=["Run", "Day", "Method", "Best Fitness", "Updated Fitness", "Execution Time (s)"])
    deviations_df = pd.DataFrame(deviations_per_day, columns=[f"Appliance {i+1}" for i in range(N)])

# Group SA results by 'Run' and calculate statistics
sa_summary = sa_results_df.groupby("Run").agg({
    "Day": "count",
    "Best Fitness": ["mean", "std", "min", "max", "median"],
    "Updated Fitness" : ["mean", "std", "min", "max", "median"],
    "Execution Time (s)": "sum"
})

# Rename columns for clarity
sa_summary.columns = [
    "Days Count",
    "Best Fitness Mean", "Best Fitness Std", "Best Fitness Min", "Best Fitness Max", "Best Fitness Median",
    "Updated Fitness Mean", "Updated Fitness Std", "Updated Fitness Min", "Updated Fitness Max", "Updated Fitness Median",
    "Total Execution Time (s)"
]
sa_summary.reset_index(inplace=True)



print("\n=====  Simulated Annealing (SA) Grouped Summary by Run =====")
print(sa_summary)

# Extract fitness values from SA results
best_fitness_sa = sa_results_df["Best Fitness"].tolist()
updated_fitness_sa = sa_results_df["Updated Fitness"].tolist()

# Compute Optimal Fitness (Sum of minimum costs per appliance)
optimal_fitness = sum(np.min(appliance_cost, axis=1))  # Smallest cost per appliance

# Generate Plot
plt.figure(figsize=(12, 6))
days = range(1, len(best_fitness_sa) + 1)


# Plot SA results
plt.plot(days, best_fitness_sa, label="Best Fitness (SA)", marker="d", linestyle="-", color="green")
#plt.plot(days, updated_fitness_sa, label="Updated Fitness (SA)", marker="^", linestyle="--", color="lime")

# Plot Optimal Fitness as a horizontal line
plt.axhline(y=optimal_fitness, color="red", linestyle="--", label="Optimal Fitness")

# Labels and Title
plt.xlabel("Day")
plt.ylabel("Fitness Value")
plt.title("Comparison of SA Fitness vs. Optimal Fitness Over Days")
plt.legend()
plt.grid(True)

# Show plot
plt.show()

"""30 RUN with try to avoid 100 fo rappliance 5, 6"""

sa_results = []
total_days = 86
runs =  30 # Run the simulation once for now
best_fitness_values = []
sa_max_iterations = 100
cooling_rate = 0.995
initial_temperature = 100000
# Initialize battery state and spillover for the first day
initial_battery_state = 0
battery_state_of_charge_sa = initial_battery_state
previous_day_spillover_sa = np.zeros((N, 2 * S))

deviations_per_day = []  # Store deviation per appliance per day
percentage_per_day = []  # Store daily percentage of appliances with a cost of 100

def calculate_deviation(actual_start_time, desired_start_time):
    return actual_start_time - desired_start_time

for rpt in range(1, runs + 1):
    print(f"\n===== Simulating Run {rpt} =====")
    battery_state_of_charge_sa = initial_battery_state
    previous_day_spillover_sa = np.zeros((N, 2 * S))

    for day in range(total_days):
        print(f"Simulating Day {day + 1}")

        current_predicted_generation = predicted_generation_train[day % len(predicted_generation_train)]
        next_predicted_generation = predicted_generation_train[(day + 1) % len(predicted_generation_train)]
        predicted_generation_48h = np.concatenate([current_predicted_generation, next_predicted_generation])

        appliance_cost = generate_cost_matrix(N, S, appliance_info)
        start_time_sa = time.time()

        best_solution_sa, best_fitness_sa = simulated_annealing_with_spillover(
            previous_day_spillover_sa,
            day,
            initial_temperature,
            cooling_rate,
            sa_max_iterations,
            battery_state_of_charge_sa,
            predicted_generation_48h,
            appliance_cost,appliance_consumption, active_durations, Q_min, Q_max, Z_min, Z_max, Θ
        )

        end_time_sa = time.time()
        daily_deviation = []
        daily_costs = []
        appliances_with_100_cost = 0  # Initialize counter

        for n in range(N):
            desired_start_time = desired_start_times[n]
            actual_start_time = find_new_start_time(
                best_solution_sa[n, :S],
                best_solution_sa[n, S:],
                np.any(previous_day_spillover_sa)
            )
            deviation = calculate_deviation(actual_start_time, desired_start_time)
            appliance_total_cost = appliance_cost[n, actual_start_time]

            if appliance_total_cost == 100:
                appliances_with_100_cost += 1

            print(f"Appliance {n+1}: Desired Start = {desired_start_time}, Actual Start = {actual_start_time}, Deviation = {deviation}, Total Cost = {appliance_total_cost}")

            daily_deviation.append(deviation)
            daily_costs.append(appliance_total_cost)

        deviations_per_day.append(daily_deviation)
        percentage_per_day.append((appliances_with_100_cost / N) * 100)

        # Step 4: Initialize daily battery state
        battery_state_sa = np.zeros(48)

        # Step 5: Simulate hourly operations for the day
        for hour in range(48):
            generation = predicted_generation_48h[hour]
            required_consumption_sa = np.sum(best_solution_sa[:, hour] * appliance_consumption)
            available_energy_sa = battery_state_of_charge_sa if hour == 0 else battery_state_sa[hour - 1]
            actual_consumption_sa = min(required_consumption_sa, available_energy_sa)
            battery_state_sa[hour] = (battery_state_of_charge_sa + generation - actual_consumption_sa
                                      if hour == 0 else
                                      battery_state_sa[hour - 1] + generation - actual_consumption_sa)
            battery_state_sa[hour] = np.clip(battery_state_sa[hour], Z_min, Z_max)
            if actual_consumption_sa < required_consumption_sa:
                best_solution_sa[:, hour] = 0  # Disable usage if insufficient energy is available

        update_best_fitness_sa = fitness(best_solution_sa, appliance_cost, previous_day_spillover_sa, np.any(previous_day_spillover_sa), penalty=1000)
        sa_results.append([rpt, day + 1, "Simulated Annealing", best_fitness_sa, update_best_fitness_sa, end_time_sa - start_time_sa])
        display_schedule(best_solution_sa, day, previous_day_spillover_sa)
        visualize_schedule_with_spillover(best_solution_sa, day, appliance_names)
        print(f"Best Fitness: {best_fitness_sa}")
        print(f"Updated Fitness: {update_best_fitness_sa}")
        display_hourly_breakdown(day, predicted_generation_48h, best_solution_sa, appliance_consumption, battery_state_sa)
        previous_day_spillover_sa = best_solution_sa
        battery_state_of_charge_sa = battery_state_sa[23]

        plt.figure(figsize=(10, 6))
        plt.plot(range(24), predicted_generation_48h[:24], label='Predicted Generation (kWh)', color='blue')
        plt.plot(range(24), [np.sum(best_solution_sa[:, hour] * appliance_consumption) for hour in range(24)], label='Consumption (kWh)', color='green')
        plt.plot(range(24), battery_state_sa[:24], label='Battery State (kWh)', color='orange')
        plt.xlabel('Time (Hour of Day)')
        plt.ylabel('Energy (kWh)')
        plt.title(f'Day {day + 1} - Predicted Generation vs Consumption vs Battery State')
        plt.legend()
        plt.grid(True)
        plt.show()

    # === Stacked Bar Chart ===
    #days = range(1, total_days + 1)
    days = list(range(1, len(percentage_per_day) + 1))
    percentage_not_cost_100 = [100 - p for p in percentage_per_day]

    plt.figure(figsize=(12, 6))
    plt.bar(days, percentage_per_day, color='salmon', edgecolor='black', label='Cost 100')
    plt.bar(days, percentage_not_cost_100, bottom=percentage_per_day, color='skyblue', edgecolor='black', label='Not Cost 100')


    # Labels & Titl
    plt.xlabel('Day')
    plt.ylabel('Percentage of Appliances')
    plt.title('Percentage of Appliances with Cost 100 vs Not Cost 100 Over Days')
    plt.xticks(range(1, total_days + 1, max(1, total_days // 10)))  # Adjust x-axis ticks dynamically
    plt.yticks(np.arange(0, 110, 10))  # Y-axis from 0 to 100 in steps of 10
    plt.legend()
    plt.grid(axis='y', linestyle='--', alpha=0.7)

    plt.show()



    sa_results_df = pd.DataFrame(sa_results, columns=["Run", "Day", "Method", "Best Fitness", "Updated Fitness", "Execution Time (s)"])
    deviations_df = pd.DataFrame(deviations_per_day, columns=[f"Appliance {i+1}" for i in range(N)])

# Group SA results by 'Run' and calculate statistics
sa_summary = sa_results_df.groupby("Run").agg({
    "Day": "count",
    "Best Fitness": ["mean", "std", "min", "max", "median"],
    "Updated Fitness" : ["mean", "std", "min", "max", "median"],
    "Execution Time (s)": "sum"
})

# Rename columns for clarity
sa_summary.columns = [
    "Days Count",
    "Best Fitness Mean", "Best Fitness Std", "Best Fitness Min", "Best Fitness Max", "Best Fitness Median",
    "Updated Fitness Mean", "Updated Fitness Std", "Updated Fitness Min", "Updated Fitness Max", "Updated Fitness Median",
    "Total Execution Time (s)"
]
sa_summary.reset_index(inplace=True)



print("\n=====  Simulated Annealing (SA) Grouped Summary by Run =====")
print(sa_summary)
# Extract relevant columns (Run, Day, Best Fitness, and Updated Fitness)
fitness_comparison_SA30Run = sa_results_df[["Run", "Day", "Best Fitness", "Updated Fitness"]]

# Optionally, reset the index for a cleaner display
fitness_comparison_SA30Run.reset_index(drop=True, inplace=True)

# Display the comparison table
print("\n===== Best Fitness vs Updated Fitness per Day =====")
print(fitness_comparison_SA30Run)

# Save the DataFrame to an Excel file
fitness_comparison_SA30Run.to_excel("fitness_comparison_SA30Run.xlsx", index=False)

print(" Fitness comparison saved to 'fitness_comparison_SA30Runs.xlsx'")

import matplotlib.pyplot as plt
import numpy as np

# Compute Optimal Fitness once
optimal_fitness = sum(np.min(appliance_cost, axis=1))  # Minimum possible total cost



# Plot each run separately
plt.figure(figsize=(14, 7))
unique_runs = sa_results_df["Run"].unique()

for run_id in unique_runs:
    run_data = sa_results_df[sa_results_df["Run"] == run_id]
    plt.plot(run_data["Day"], run_data["Best Fitness"], label=f"Run {run_id}", marker='o', linestyle='-')
    # plt.plot(run_data["Day"], run_data["Updated Fitness"], label=f"Run {run_id}", marker='^', linestyle='--')

plt.axhline(y=optimal_fitness, color='red', linestyle='--', label="Optimal Fitness")

plt.xlabel("Day")
plt.ylabel("Fitness Value")
plt.title("Simulated Annealing: Best Fitness per Run vs. Optimal")
plt.legend(loc='upper right', bbox_to_anchor=(1.25, 1))
plt.grid(True)
plt.tight_layout()
plt.show()

valid_slot_dict = {
    0: (0, 23),
    1: (7, 23),
    2: (0, 23),
    3: (0, 23),
    4: (0, 23),
    5: (17, 19),  # Appliance 5 must start at 17, 18, or 19
    6: (21, 23),
    7: (0, 23),
    8: (0, 23),
    9: (0, 23),
    10: (0, 23)
}

"""Updatedsimulated_annealing with valid_slot_dict"""

def simulated_annealing_with_spillover(
    previous_day_spillover, day, initial_temperature, cooling_rate, max_iterations,
    battery_state_of_charge, predicted_generation, appliance_cost, appliance_consumption,
    active_durations, Q_min, Q_max, Z_min, Z_max, Θ, valid_slot_dict
):

    S = 24  # Total slots for scheduling (24 hours + 24 spillover slots)

    if day == 0:
        current_solution = generate_random_solution_with_constraints(battery_state_of_charge, predicted_generation)
    else:
        current_solution = prepare_next_day_initial_solution(previous_day_spillover, day)

    is_spillover_day = np.any(previous_day_spillover)
    spillover_slots = np.copy(previous_day_spillover)

    current_fitness = fitness(current_solution, appliance_cost, spillover_slots, is_spillover_day)
    best_solution = np.copy(current_solution)
    best_fitness = current_fitness
    temperature = initial_temperature

    appliances = list(range(len(appliance_cost)))

    fitness_progression = [current_fitness]

    for iteration in range(max_iterations):
        print(f"\nIteration {iteration + 1}")
        np.random.shuffle(appliances)

        for appliance_to_modify in appliances:
            new_solution = np.copy(current_solution)
            duration = active_durations[appliance_to_modify]

            # Enforce valid start slot range
            valid_start_min, valid_start_max = valid_slot_dict.get(appliance_to_modify, (0, 23))
            valid_start_max = min(valid_start_max, S - duration)

            if valid_start_max < valid_start_min:
                print(f"  Appliance {appliance_to_modify} skipped (invalid start range).")
                continue

            start_slot = np.random.randint(valid_start_min, valid_start_max + 1)
            end_slot = start_slot + duration

            print(f"  Appliance {appliance_to_modify} tries start at {start_slot} (duration {duration})")

            # Reset appliance schedule
            new_solution[appliance_to_modify, :] = 0

            if end_slot <= S:
                new_solution[appliance_to_modify, start_slot:end_slot] = 1
            else:
                new_solution[appliance_to_modify, start_slot:S] = 1
                spillover_duration = end_slot - S
                new_solution[appliance_to_modify, S:S + spillover_duration] = 1

            # Constraint checking
            valid_solution = True
            battery_state = float(battery_state_of_charge)

            for hour in range(2 * S):
                generation = np.clip(predicted_generation[hour], Q_min, Q_max)
                demand = np.sum(new_solution[:, hour] * appliance_consumption)

                if demand > Θ or demand > battery_state:
                    valid_solution = False
                    break

                battery_state += generation - demand
                if battery_state < Z_min or battery_state > Z_max:
                    valid_solution = False
                    break

            if valid_solution:
                new_fitness = fitness(new_solution, appliance_cost, spillover_slots, is_spillover_day)

                if new_fitness < best_fitness:
                    best_solution = np.copy(new_solution)
                    best_fitness = new_fitness

                acceptance_prob = np.exp((current_fitness - new_fitness) / temperature)
                if new_fitness < current_fitness or np.random.rand() < acceptance_prob:
                    current_solution = np.copy(new_solution)
                    current_fitness = new_fitness

                break  # Stop retrying this appliance once valid modification is found

        fitness_progression.append(best_fitness)
        temperature *= cooling_rate

    # Plot fitness progression
    plt.figure(figsize=(10, 6))
    plt.plot(fitness_progression, label="Best Fitness")
    plt.xlabel('Iteration')
    plt.ylabel('Fitness')
    plt.title('Fitness Progression Over Iterations')
    plt.grid(True)
    plt.legend()
    plt.show()

    return best_solution, best_fitness

sa_results = []
total_days = 86
runs =  1 # Run the simulation once for now
best_fitness_values = []
sa_max_iterations = 100
cooling_rate = 0.995
initial_temperature = 100000
# Initialize battery state and spillover for the first day
initial_battery_state = 0
battery_state_of_charge_sa = initial_battery_state
previous_day_spillover_sa = np.zeros((N, 2 * S))

deviations_per_day = []  # Store deviation per appliance per day
percentage_per_day = []  # Store daily percentage of appliances with a cost of 100

def calculate_deviation(actual_start_time, desired_start_time):
    return actual_start_time - desired_start_time

for rpt in range(1, runs + 1):
    print(f"\n===== Simulating Run {rpt} =====")
    battery_state_of_charge_sa = initial_battery_state
    previous_day_spillover_sa = np.zeros((N, 2 * S))

    for day in range(total_days):
        print(f"Simulating Day {day + 1}")

        current_predicted_generation = predicted_generation_train[day % len(predicted_generation_train)]
        next_predicted_generation = predicted_generation_train[(day + 1) % len(predicted_generation_train)]
        predicted_generation_48h = np.concatenate([current_predicted_generation, next_predicted_generation])

        appliance_cost = generate_cost_matrix(N, S, appliance_info)
        start_time_sa = time.time()

        best_solution_sa, best_fitness_sa = simulated_annealing_with_spillover(
            previous_day_spillover_sa,
            day,
            initial_temperature,
            cooling_rate,
            sa_max_iterations,
            battery_state_of_charge_sa,
            predicted_generation_48h,
            appliance_cost,appliance_consumption, active_durations, Q_min, Q_max, Z_min, Z_max, Θ, valid_slot_dict
        )

        end_time_sa = time.time()
        daily_deviation = []
        daily_costs = []
        appliances_with_100_cost = 0  # Initialize counter

        for n in range(N):
            desired_start_time = desired_start_times[n]
            actual_start_time = find_new_start_time(
                best_solution_sa[n, :S],
                best_solution_sa[n, S:],
                np.any(previous_day_spillover_sa)
            )
            deviation = calculate_deviation(actual_start_time, desired_start_time)
            appliance_total_cost = appliance_cost[n, actual_start_time]

            if appliance_total_cost == 100:
                appliances_with_100_cost += 1

            print(f"Appliance {n+1}: Desired Start = {desired_start_time}, Actual Start = {actual_start_time}, Deviation = {deviation}, Total Cost = {appliance_total_cost}")

            daily_deviation.append(deviation)
            daily_costs.append(appliance_total_cost)

        deviations_per_day.append(daily_deviation)
        percentage_per_day.append((appliances_with_100_cost / N) * 100)

        # Step 4: Initialize daily battery state
        battery_state_sa = np.zeros(48)

        # Step 5: Simulate hourly operations for the day
        for hour in range(48):
            generation = predicted_generation_48h[hour]
            required_consumption_sa = np.sum(best_solution_sa[:, hour] * appliance_consumption)
            available_energy_sa = battery_state_of_charge_sa if hour == 0 else battery_state_sa[hour - 1]
            actual_consumption_sa = min(required_consumption_sa, available_energy_sa)
            battery_state_sa[hour] = (battery_state_of_charge_sa + generation - actual_consumption_sa
                                      if hour == 0 else
                                      battery_state_sa[hour - 1] + generation - actual_consumption_sa)
            battery_state_sa[hour] = np.clip(battery_state_sa[hour], Z_min, Z_max)
            if actual_consumption_sa < required_consumption_sa:
                best_solution_sa[:, hour] = 0  # Disable usage if insufficient energy is available

        update_best_fitness_sa = fitness(best_solution_sa, appliance_cost, previous_day_spillover_sa, np.any(previous_day_spillover_sa), penalty=1000)
        sa_results.append([rpt, day + 1, "Simulated Annealing", best_fitness_sa, update_best_fitness_sa, end_time_sa - start_time_sa])
        display_schedule(best_solution_sa, day, previous_day_spillover_sa)
        visualize_schedule_with_spillover(best_solution_sa, day, appliance_names)
        print(f"Best Fitness: {best_fitness_sa}")
        print(f"Updated Fitness: {update_best_fitness_sa}")
        display_hourly_breakdown(day, predicted_generation_48h, best_solution_sa, appliance_consumption, battery_state_sa)
        previous_day_spillover_sa = best_solution_sa
        battery_state_of_charge_sa = battery_state_sa[23]

        plt.figure(figsize=(10, 6))
        plt.plot(range(24), predicted_generation_48h[:24], label='Predicted Generation (kWh)', color='blue')
        plt.plot(range(24), [np.sum(best_solution_sa[:, hour] * appliance_consumption) for hour in range(24)], label='Consumption (kWh)', color='green')
        plt.plot(range(24), battery_state_sa[:24], label='Battery State (kWh)', color='orange')
        plt.xlabel('Time (Hour of Day)')
        plt.ylabel('Energy (kWh)')
        plt.title(f'Day {day + 1} - Predicted Generation vs Consumption vs Battery State')
        plt.legend()
        plt.grid(True)
        plt.show()

    # === Stacked Bar Chart ===
    days = range(1, total_days + 1)
    percentage_not_cost_100 = [100 - p for p in percentage_per_day]

    plt.figure(figsize=(12, 6))
    plt.bar(days, percentage_per_day, color='salmon', edgecolor='black', label='Cost 100')
    plt.bar(days, percentage_not_cost_100, bottom=percentage_per_day, color='skyblue', edgecolor='black', label='Not Cost 100')


    # Labels & Titl
    plt.xlabel('Day')
    plt.ylabel('Percentage of Appliances')
    plt.title('Percentage of Appliances with Cost 100 vs Not Cost 100 Over Days')
    plt.xticks(range(1, total_days + 1, max(1, total_days // 10)))  # Adjust x-axis ticks dynamically
    plt.yticks(np.arange(0, 110, 10))  # Y-axis from 0 to 100 in steps of 10
    plt.legend()
    plt.grid(axis='y', linestyle='--', alpha=0.7)

    plt.show()



    sa_results_df = pd.DataFrame(sa_results, columns=["Run", "Day", "Method", "Best Fitness", "Updated Fitness", "Execution Time (s)"])
    deviations_df = pd.DataFrame(deviations_per_day, columns=[f"Appliance {i+1}" for i in range(N)])

# Group SA results by 'Run' and calculate statistics
sa_summary = sa_results_df.groupby("Run").agg({
    "Day": "count",
    "Best Fitness": ["mean", "std", "min", "max", "median"],
    "Updated Fitness" : ["mean", "std", "min", "max", "median"],
    "Execution Time (s)": "sum"
})

# Rename columns for clarity
sa_summary.columns = [
    "Days Count",
    "Best Fitness Mean", "Best Fitness Std", "Best Fitness Min", "Best Fitness Max", "Best Fitness Median",
    "Updated Fitness Mean", "Updated Fitness Std", "Updated Fitness Min", "Updated Fitness Max", "Updated Fitness Median",
    "Total Execution Time (s)"
]
sa_summary.reset_index(inplace=True)



print("\n=====  Simulated Annealing (SA) Grouped Summary by Run =====")
print(sa_summary)

# Group SA results by 'Run' and calculate statistics
sa_summary = sa_results_df.groupby("Run").agg({
    "Day": "count",
    "Best Fitness": ["mean", "std", "min", "max", "median"],
    "Updated Fitness" : ["mean", "std", "min", "max", "median"],
    "Execution Time (s)": "sum"
})

# Rename columns for clarity
sa_summary.columns = [
    "Days Count",
    "Best Fitness Mean", "Best Fitness Std", "Best Fitness Min", "Best Fitness Max", "Best Fitness Median",
    "Updated Fitness Mean", "Updated Fitness Std", "Updated Fitness Min", "Updated Fitness Max", "Updated Fitness Median",
    "Total Execution Time (s)"
]
sa_summary.reset_index(inplace=True)



print("\n=====  Simulated Annealing (SA) Grouped Summary by Run =====")
print(sa_summary)

# Extract fitness values from SA results
best_fitness_sa = sa_results_df["Best Fitness"].tolist()
updated_fitness_sa = sa_results_df["Updated Fitness"].tolist()

# Compute Optimal Fitness (Sum of minimum costs per appliance)
optimal_fitness = sum(np.min(appliance_cost, axis=1))  # Smallest cost per appliance

# Generate Plot
plt.figure(figsize=(12, 6))
days = range(1, len(best_fitness_sa) + 1)


# Plot SA results
plt.plot(days, best_fitness_sa, label="Best Fitness (SA)", marker="d", linestyle="-", color="green")
#plt.plot(days, updated_fitness_sa, label="Updated Fitness (SA)", marker="^", linestyle="--", color="lime")

# Plot Optimal Fitness as a horizontal line
plt.axhline(y=optimal_fitness, color="red", linestyle="--", label="Optimal Fitness")

# Labels and Title
plt.xlabel("Day")
plt.ylabel("Fitness Value")
plt.title("Comparison of SA Fitness vs. Optimal Fitness Over Days")
plt.legend()
plt.grid(True)

# Show plot
plt.show()

# Extract fitness values from SA results
best_fitness_sa = sa_results_df["Best Fitness"].tolist()
updated_fitness_sa = sa_results_df["Updated Fitness"].tolist()

# Compute Optimal Fitness (Sum of minimum costs per appliance)
optimal_fitness = sum(np.min(appliance_cost, axis=1))  # Smallest cost per appliance

# Generate Plot
plt.figure(figsize=(12, 6))
days = range(1, len(best_fitness_sa) + 1)


# Plot SA results
plt.plot(days, best_fitness_sa, label="Best Fitness (SA)", marker="d", linestyle="-", color="green")
#plt.plot(days, updated_fitness_sa, label="Updated Fitness (SA)", marker="^", linestyle="--", color="lime")

# Plot Optimal Fitness as a horizontal line
plt.axhline(y=optimal_fitness, color="red", linestyle="--", label="Optimal Fitness")

# Labels and Title
plt.xlabel("Day")
plt.ylabel("Fitness Value")
plt.title("Comparison of SA Fitness vs. Optimal Fitness Over Days")
plt.legend()
plt.grid(True)

# Show plot
plt.show()

"""Updated generate_random_solution_with_constraints with valid_slot_dict"""

def generate_random_solution_with_constraints(battery_state_of_charge, predicted_generation, valid_slot_dict):
    """
    Generate a valid random solution while respecting appliance time constraints.
    """
    solution = np.zeros((N, 2 * S), dtype=int)
    appliances = list(range(N))
    np.random.shuffle(appliances)

    for n in appliances:
        valid = False
        duration = active_durations[n]
        slot_min, slot_max = valid_slot_dict.get(n, (0, 23))
        slot_max = min(slot_max, S - duration)

        if slot_max < slot_min:
            continue  # Skip if no valid range

        for _ in range(10):
            start_slot = np.random.randint(slot_min, slot_max + 1)
            end_slot = start_slot + duration

            if np.sum(solution[n, start_slot:end_slot]) == 0:
                solution[n, start_slot:end_slot] = 1
                temp_battery_state_of_charge = battery_state_of_charge
                valid = True

                for s in range(S):
                    temp_battery_state_of_charge += np.clip(predicted_generation[s], Q_min, Q_max)
                    total_power = np.sum(solution[:, s] * power_consumption)

                    if total_power > Θ or total_power > temp_battery_state_of_charge:
                        valid = False
                        break

                    temp_battery_state_of_charge -= total_power
                    temp_battery_state_of_charge = np.clip(temp_battery_state_of_charge, Z_min, Z_max)

                if valid:
                    break
                else:
                    solution[n, start_slot:end_slot] = 0

    return solution


def prepare_next_day_initial_solution(previous_day_spillover, day, valid_slot_dict):
    """
    Prepares the initial solution for the next day using spillover and random scheduling
    that respects valid time constraints.
    """
    solution = np.zeros((N, 2 * S), dtype=int)
    solution[:, :S] = previous_day_spillover[:, S:]  # Carry spillover from previous day

    for n in range(N):
        already_scheduled = np.sum(solution[n, :S])
        remaining = active_durations[n] - already_scheduled

        if remaining <= 0:
            continue

        duration = remaining
        slot_min, slot_max = valid_slot_dict.get(n, (0, 23))
        slot_max = min(slot_max, S - duration)

        if slot_max < slot_min:
            continue  # Invalid range

        for _ in range(10):
            start_slot = np.random.randint(slot_min, slot_max + 1)
            end_slot = start_slot + duration

            if np.sum(solution[n, start_slot:end_slot]) == 0:
                solution[n, start_slot:end_slot] = 1
                break

    return solution

#Updated Function (Fully Constraint-Aware):
def generate_random_solution_with_constraints(battery_state_of_charge, predicted_generation, valid_slot_dict):
    """
    Generate a valid random solution while respecting appliance time constraints and system constraints.
    """
    solution = np.zeros((N, 2 * S), dtype=int)
    appliances = list(range(N))
    np.random.shuffle(appliances)

    for n in appliances:
        valid = False
        duration = active_durations[n]
        slot_min, slot_max = valid_slot_dict.get(n, (0, S - 1))
        slot_max = min(slot_max, S - duration)  # ensure it fits in current day

        if slot_max < slot_min:
            continue  # No valid time window

        for _ in range(10):
            start_slot = np.random.randint(slot_min, slot_max + 1)
            end_slot = start_slot + duration

            # Try scheduling within current day
            solution[n, :] = 0  # Clear any previous attempts
            solution[n, start_slot:end_slot] = 1

            # Validate full solution under constraints
            temp_battery = float(battery_state_of_charge)
            valid = True

            for s in range(2 * S):  # Check over full 2-day span
                gen = np.clip(predicted_generation[s], Q_min, Q_max)
                demand = np.sum(solution[:, s] * power_consumption)

                if demand > Θ or demand > temp_battery:
                    valid = False
                    break

                temp_battery += gen - demand
                if temp_battery < Z_min or temp_battery > Z_max:
                    valid = False
                    break

            if valid:
                break  # Found a valid slot
            else:
                solution[n, start_slot:end_slot] = 0  # Undo and retry

    return solution
def prepare_next_day_initial_solution(previous_day_spillover, day, valid_slot_dict):
    """
    Prepares the initial solution for the next day using spillover and random scheduling
    that respects valid time constraints.
    """
    solution = np.zeros((N, 2 * S), dtype=int)
    solution[:, :S] = previous_day_spillover[:, S:]  # Carry spillover from previous day

    for n in range(N):
        already_scheduled = np.sum(solution[n, :S])
        remaining = active_durations[n] - already_scheduled

        if remaining <= 0:
            continue

        duration = remaining
        slot_min, slot_max = valid_slot_dict.get(n, (0, 23))
        slot_max = min(slot_max, S - duration)

        if slot_max < slot_min:
            continue  # Invalid range

        for _ in range(10):
            start_slot = np.random.randint(slot_min, slot_max + 1)
            end_slot = start_slot + duration

            if np.sum(solution[n, start_slot:end_slot]) == 0:
                solution[n, start_slot:end_slot] = 1
                break

    return solution

def simulated_annealing_with_spillover(
    previous_day_spillover, day, initial_temperature, cooling_rate, max_iterations,
    battery_state_of_charge, predicted_generation, appliance_cost, appliance_consumption,
    active_durations, Q_min, Q_max, Z_min, Z_max, Θ, valid_slot_dict
):

    S = 24  # Total slots for scheduling (24 hours + 24 spillover slots)

    if day == 0:
        current_solution = generate_random_solution_with_constraints(battery_state_of_charge, predicted_generation, valid_slot_dict)
    else:
        current_solution = prepare_next_day_initial_solution(previous_day_spillover, day, valid_slot_dict)

    is_spillover_day = np.any(previous_day_spillover)
    spillover_slots = np.copy(previous_day_spillover)

    current_fitness = fitness(current_solution, appliance_cost, spillover_slots, is_spillover_day)
    best_solution = np.copy(current_solution)
    best_fitness = current_fitness
    temperature = initial_temperature

    appliances = list(range(len(appliance_cost)))

    fitness_progression = [current_fitness]

    for iteration in range(max_iterations):
        print(f"\nIteration {iteration + 1}")
        np.random.shuffle(appliances)

        for appliance_to_modify in appliances:
            new_solution = np.copy(current_solution)
            duration = active_durations[appliance_to_modify]

            # Enforce valid start slot range
            valid_start_min, valid_start_max = valid_slot_dict.get(appliance_to_modify, (0, 23))
            valid_start_max = min(valid_start_max, S - duration)

            if valid_start_max < valid_start_min:
                print(f"  Appliance {appliance_to_modify} skipped (invalid start range).")
                continue

            start_slot = np.random.randint(valid_start_min, valid_start_max + 1)
            end_slot = start_slot + duration

            print(f"  Appliance {appliance_to_modify} tries start at {start_slot} (duration {duration})")

            # Reset appliance schedule
            new_solution[appliance_to_modify, :] = 0

            if end_slot <= S:
                new_solution[appliance_to_modify, start_slot:end_slot] = 1
            else:
                new_solution[appliance_to_modify, start_slot:S] = 1
                spillover_duration = end_slot - S
                new_solution[appliance_to_modify, S:S + spillover_duration] = 1

            # Constraint checking
            valid_solution = True
            battery_state = float(battery_state_of_charge)

            for hour in range(2 * S):
                generation = np.clip(predicted_generation[hour], Q_min, Q_max)
                demand = np.sum(new_solution[:, hour] * appliance_consumption)

                if demand > Θ or demand > battery_state:
                    valid_solution = False
                    break

                battery_state += generation - demand
                if battery_state < Z_min or battery_state > Z_max:
                    valid_solution = False
                    break

            if valid_solution:
                new_fitness = fitness(new_solution, appliance_cost, spillover_slots, is_spillover_day)

                if new_fitness < best_fitness:
                    best_solution = np.copy(new_solution)
                    best_fitness = new_fitness

                acceptance_prob = np.exp((current_fitness - new_fitness) / temperature)
                if new_fitness < current_fitness or np.random.rand() < acceptance_prob:
                    current_solution = np.copy(new_solution)
                    current_fitness = new_fitness

                break  # Stop retrying this appliance once valid modification is found

        fitness_progression.append(best_fitness)
        temperature *= cooling_rate

    # Plot fitness progression
    plt.figure(figsize=(10, 6))
    plt.plot(fitness_progression, label="Best Fitness")
    plt.xlabel('Iteration')
    plt.ylabel('Fitness')
    plt.title('Fitness Progression Over Iterations')
    plt.grid(True)
    plt.legend()
    plt.show()

    return best_solution, best_fitness

sa_results = []
total_days = 86
runs =  1 # Run the simulation once for now
best_fitness_values = []
sa_max_iterations = 100
cooling_rate = 0.995
initial_temperature = 100000
# Initialize battery state and spillover for the first day
initial_battery_state = 0
battery_state_of_charge_sa = initial_battery_state
previous_day_spillover_sa = np.zeros((N, 2 * S))

deviations_per_day = []  # Store deviation per appliance per day
percentage_per_day = []  # Store daily percentage of appliances with a cost of 100

def calculate_deviation(actual_start_time, desired_start_time):
    return actual_start_time - desired_start_time

for rpt in range(1, runs + 1):
    print(f"\n===== Simulating Run {rpt} =====")
    battery_state_of_charge_sa = initial_battery_state
    previous_day_spillover_sa = np.zeros((N, 2 * S))

    for day in range(total_days):
        print(f"Simulating Day {day + 1}")

        current_predicted_generation = predicted_generation_train[day % len(predicted_generation_train)]
        next_predicted_generation = predicted_generation_train[(day + 1) % len(predicted_generation_train)]
        predicted_generation_48h = np.concatenate([current_predicted_generation, next_predicted_generation])

        appliance_cost = generate_cost_matrix(N, S, appliance_info)
        start_time_sa = time.time()

        best_solution_sa, best_fitness_sa = simulated_annealing_with_spillover(
            previous_day_spillover_sa,
            day,
            initial_temperature,
            cooling_rate,
            sa_max_iterations,
            battery_state_of_charge_sa,
            predicted_generation_48h,
            appliance_cost,appliance_consumption, active_durations, Q_min, Q_max, Z_min, Z_max, Θ, valid_slot_dict
        )

        end_time_sa = time.time()
        daily_deviation = []
        daily_costs = []
        appliances_with_100_cost = 0  # Initialize counter

        for n in range(N):
            desired_start_time = desired_start_times[n]
            actual_start_time = find_new_start_time(
                best_solution_sa[n, :S],
                best_solution_sa[n, S:],
                np.any(previous_day_spillover_sa)
            )
            deviation = calculate_deviation(actual_start_time, desired_start_time)
            appliance_total_cost = appliance_cost[n, actual_start_time]

            if appliance_total_cost == 100:
                appliances_with_100_cost += 1

            print(f"Appliance {n+1}: Desired Start = {desired_start_time}, Actual Start = {actual_start_time}, Deviation = {deviation}, Total Cost = {appliance_total_cost}")

            daily_deviation.append(deviation)
            daily_costs.append(appliance_total_cost)

        deviations_per_day.append(daily_deviation)
        percentage_per_day.append((appliances_with_100_cost / N) * 100)

        # Step 4: Initialize daily battery state
        battery_state_sa = np.zeros(48)

        # Step 5: Simulate hourly operations for the day
        for hour in range(48):
            generation = predicted_generation_48h[hour]
            required_consumption_sa = np.sum(best_solution_sa[:, hour] * appliance_consumption)
            available_energy_sa = battery_state_of_charge_sa if hour == 0 else battery_state_sa[hour - 1]
            actual_consumption_sa = min(required_consumption_sa, available_energy_sa)
            battery_state_sa[hour] = (battery_state_of_charge_sa + generation - actual_consumption_sa
                                      if hour == 0 else
                                      battery_state_sa[hour - 1] + generation - actual_consumption_sa)
            battery_state_sa[hour] = np.clip(battery_state_sa[hour], Z_min, Z_max)
            if actual_consumption_sa < required_consumption_sa:
                best_solution_sa[:, hour] = 0  # Disable usage if insufficient energy is available

        update_best_fitness_sa = fitness(best_solution_sa, appliance_cost, previous_day_spillover_sa, np.any(previous_day_spillover_sa), penalty=1000)
        sa_results.append([rpt, day + 1, "Simulated Annealing", best_fitness_sa, update_best_fitness_sa, end_time_sa - start_time_sa])
        display_schedule(best_solution_sa, day, previous_day_spillover_sa)
        visualize_schedule_with_spillover(best_solution_sa, day, appliance_names)
        print(f"Best Fitness: {best_fitness_sa}")
        print(f"Updated Fitness: {update_best_fitness_sa}")
        display_hourly_breakdown(day, predicted_generation_48h, best_solution_sa, appliance_consumption, battery_state_sa)
        previous_day_spillover_sa = best_solution_sa
        battery_state_of_charge_sa = battery_state_sa[23]

        plt.figure(figsize=(10, 6))
        plt.plot(range(24), predicted_generation_48h[:24], label='Predicted Generation (kWh)', color='blue')
        plt.plot(range(24), [np.sum(best_solution_sa[:, hour] * appliance_consumption) for hour in range(24)], label='Consumption (kWh)', color='green')
        plt.plot(range(24), battery_state_sa[:24], label='Battery State (kWh)', color='orange')
        plt.xlabel('Time (Hour of Day)')
        plt.ylabel('Energy (kWh)')
        plt.title(f'Day {day + 1} - Predicted Generation vs Consumption vs Battery State')
        plt.legend()
        plt.grid(True)
        plt.show()

    # === Stacked Bar Chart ===
    days = range(1, total_days + 1)
    percentage_not_cost_100 = [100 - p for p in percentage_per_day]

    plt.figure(figsize=(12, 6))
    plt.bar(days, percentage_per_day, color='salmon', edgecolor='black', label='Cost 100')
    plt.bar(days, percentage_not_cost_100, bottom=percentage_per_day, color='skyblue', edgecolor='black', label='Not Cost 100')


    # Labels & Titl
    plt.xlabel('Day')
    plt.ylabel('Percentage of Appliances')
    plt.title('Percentage of Appliances with Cost 100 vs Not Cost 100 Over Days')
    plt.xticks(range(1, total_days + 1, max(1, total_days // 10)))  # Adjust x-axis ticks dynamically
    plt.yticks(np.arange(0, 110, 10))  # Y-axis from 0 to 100 in steps of 10
    plt.legend()
    plt.grid(axis='y', linestyle='--', alpha=0.7)

    plt.show()



    sa_results_df = pd.DataFrame(sa_results, columns=["Run", "Day", "Method", "Best Fitness", "Updated Fitness", "Execution Time (s)"])
    deviations_df = pd.DataFrame(deviations_per_day, columns=[f"Appliance {i+1}" for i in range(N)])

# Group SA results by 'Run' and calculate statistics
sa_summary = sa_results_df.groupby("Run").agg({
    "Day": "count",
    "Best Fitness": ["mean", "std", "min", "max", "median"],
    "Updated Fitness" : ["mean", "std", "min", "max", "median"],
    "Execution Time (s)": "sum"
})

# Rename columns for clarity
sa_summary.columns = [
    "Days Count",
    "Best Fitness Mean", "Best Fitness Std", "Best Fitness Min", "Best Fitness Max", "Best Fitness Median",
    "Updated Fitness Mean", "Updated Fitness Std", "Updated Fitness Min", "Updated Fitness Max", "Updated Fitness Median",
    "Total Execution Time (s)"
]
sa_summary.reset_index(inplace=True)



print("\n=====  Simulated Annealing (SA) Grouped Summary by Run =====")
print(sa_summary)

# Extract fitness values from SA results
best_fitness_sa = sa_results_df["Best Fitness"].tolist()
updated_fitness_sa = sa_results_df["Updated Fitness"].tolist()

# Compute Optimal Fitness (Sum of minimum costs per appliance)
optimal_fitness = sum(np.min(appliance_cost, axis=1))  # Smallest cost per appliance

# Generate Plot
plt.figure(figsize=(12, 6))
days = range(1, len(best_fitness_sa) + 1)


# Plot SA results
plt.plot(days, best_fitness_sa, label="Best Fitness (SA)", marker="d", linestyle="-", color="green")
plt.plot(days, updated_fitness_sa, label="Updated Fitness (SA)", marker="^", linestyle="--", color="lime")

# Plot Optimal Fitness as a horizontal line
plt.axhline(y=optimal_fitness, color="red", linestyle="--", label="Optimal Fitness")

# Labels and Title
plt.xlabel("Day")
plt.ylabel("Fitness Value")
plt.title("Comparison of SA Fitness vs. Optimal Fitness Over Days")
plt.legend()
plt.grid(True)

# Show plot
plt.show()

sa_results = []
total_days = 86
runs =  30 # Run the simulation once for now
best_fitness_values = []
sa_max_iterations = 100
cooling_rate = 0.995
initial_temperature = 100000
# Initialize battery state and spillover for the first day
initial_battery_state = 0
battery_state_of_charge_sa = initial_battery_state
previous_day_spillover_sa = np.zeros((N, 2 * S))

deviations_per_day = []  # Store deviation per appliance per day
percentage_per_day = []  # Store daily percentage of appliances with a cost of 100

def calculate_deviation(actual_start_time, desired_start_time):
    return actual_start_time - desired_start_time

for rpt in range(1, runs + 1):
    print(f"\n===== Simulating Run {rpt} =====")
    battery_state_of_charge_sa = initial_battery_state
    previous_day_spillover_sa = np.zeros((N, 2 * S))

    for day in range(total_days):
        print(f"Simulating Day {day + 1}")

        current_predicted_generation = predicted_generation_train[day % len(predicted_generation_train)]
        next_predicted_generation = predicted_generation_train[(day + 1) % len(predicted_generation_train)]
        predicted_generation_48h = np.concatenate([current_predicted_generation, next_predicted_generation])

        appliance_cost = generate_cost_matrix(N, S, appliance_info)
        start_time_sa = time.time()

        best_solution_sa, best_fitness_sa = simulated_annealing_with_spillover(
            previous_day_spillover_sa,
            day,
            initial_temperature,
            cooling_rate,
            sa_max_iterations,
            battery_state_of_charge_sa,
            predicted_generation_48h,
            appliance_cost,appliance_consumption, active_durations, Q_min, Q_max, Z_min, Z_max, Θ, valid_slot_dict
        )

        end_time_sa = time.time()
        daily_deviation = []
        daily_costs = []
        appliances_with_100_cost = 0  # Initialize counter

        for n in range(N):
            desired_start_time = desired_start_times[n]
            actual_start_time = find_new_start_time(
                best_solution_sa[n, :S],
                best_solution_sa[n, S:],
                np.any(previous_day_spillover_sa)
            )
            deviation = calculate_deviation(actual_start_time, desired_start_time)
            appliance_total_cost = appliance_cost[n, actual_start_time]

            if appliance_total_cost == 100:
                appliances_with_100_cost += 1

            print(f"Appliance {n+1}: Desired Start = {desired_start_time}, Actual Start = {actual_start_time}, Deviation = {deviation}, Total Cost = {appliance_total_cost}")

            daily_deviation.append(deviation)
            daily_costs.append(appliance_total_cost)

        deviations_per_day.append(daily_deviation)
        percentage_per_day.append((appliances_with_100_cost / N) * 100)

        # Step 4: Initialize daily battery state
        battery_state_sa = np.zeros(48)

        # Step 5: Simulate hourly operations for the day
        for hour in range(48):
            generation = predicted_generation_48h[hour]
            required_consumption_sa = np.sum(best_solution_sa[:, hour] * appliance_consumption)
            available_energy_sa = battery_state_of_charge_sa if hour == 0 else battery_state_sa[hour - 1]
            actual_consumption_sa = min(required_consumption_sa, available_energy_sa)
            battery_state_sa[hour] = (battery_state_of_charge_sa + generation - actual_consumption_sa
                                      if hour == 0 else
                                      battery_state_sa[hour - 1] + generation - actual_consumption_sa)
            battery_state_sa[hour] = np.clip(battery_state_sa[hour], Z_min, Z_max)
            if actual_consumption_sa < required_consumption_sa:
                best_solution_sa[:, hour] = 0  # Disable usage if insufficient energy is available

        update_best_fitness_sa = fitness(best_solution_sa, appliance_cost, previous_day_spillover_sa, np.any(previous_day_spillover_sa), penalty=1000)
        sa_results.append([rpt, day + 1, "Simulated Annealing", best_fitness_sa, update_best_fitness_sa, end_time_sa - start_time_sa])
        display_schedule(best_solution_sa, day, previous_day_spillover_sa)
        visualize_schedule_with_spillover(best_solution_sa, day, appliance_names)
        print(f"Best Fitness: {best_fitness_sa}")
        print(f"Updated Fitness: {update_best_fitness_sa}")
        display_hourly_breakdown(day, predicted_generation_48h, best_solution_sa, appliance_consumption, battery_state_sa)
        previous_day_spillover_sa = best_solution_sa
        battery_state_of_charge_sa = battery_state_sa[23]

        plt.figure(figsize=(10, 6))
        plt.plot(range(24), predicted_generation_48h[:24], label='Predicted Generation (kWh)', color='blue')
        plt.plot(range(24), [np.sum(best_solution_sa[:, hour] * appliance_consumption) for hour in range(24)], label='Consumption (kWh)', color='green')
        plt.plot(range(24), battery_state_sa[:24], label='Battery State (kWh)', color='orange')
        plt.xlabel('Time (Hour of Day)')
        plt.ylabel('Energy (kWh)')
        plt.title(f'Day {day + 1} - Predicted Generation vs Consumption vs Battery State')
        plt.legend()
        plt.grid(True)
        plt.show()

    # === Stacked Bar Chart ===
    #days = range(1, total_days + 1)
    days = list(range(1, len(percentage_per_day) + 1))
    percentage_not_cost_100 = [100 - p for p in percentage_per_day]

    plt.figure(figsize=(12, 6))
    plt.bar(days, percentage_per_day, color='salmon', edgecolor='black', label='Cost 100')
    plt.bar(days, percentage_not_cost_100, bottom=percentage_per_day, color='skyblue', edgecolor='black', label='Not Cost 100')


    # Labels & Titl
    plt.xlabel('Day')
    plt.ylabel('Percentage of Appliances')
    plt.title('Percentage of Appliances with Cost 100 vs Not Cost 100 Over Days')
    plt.xticks(range(1, total_days + 1, max(1, total_days // 10)))  # Adjust x-axis ticks dynamically
    plt.yticks(np.arange(0, 110, 10))  # Y-axis from 0 to 100 in steps of 10
    plt.legend()
    plt.grid(axis='y', linestyle='--', alpha=0.7)

    plt.show()



    sa_results_df = pd.DataFrame(sa_results, columns=["Run", "Day", "Method", "Best Fitness", "Updated Fitness", "Execution Time (s)"])
    deviations_df = pd.DataFrame(deviations_per_day, columns=[f"Appliance {i+1}" for i in range(N)])

# Group SA results by 'Run' and calculate statistics
sa_summary = sa_results_df.groupby("Run").agg({
    "Day": "count",
    "Best Fitness": ["mean", "std", "min", "max", "median"],
    "Updated Fitness" : ["mean", "std", "min", "max", "median"],
    "Execution Time (s)": "sum"
})

# Rename columns for clarity
sa_summary.columns = [
    "Days Count",
    "Best Fitness Mean", "Best Fitness Std", "Best Fitness Min", "Best Fitness Max", "Best Fitness Median",
    "Updated Fitness Mean", "Updated Fitness Std", "Updated Fitness Min", "Updated Fitness Max", "Updated Fitness Median",
    "Total Execution Time (s)"
]
sa_summary.reset_index(inplace=True)



print("\n=====  Simulated Annealing (SA) Grouped Summary by Run =====")
print(sa_summary)
# Extract relevant columns (Run, Day, Best Fitness, and Updated Fitness)
fitness_comparison_SA30Run = sa_results_df[["Run", "Day", "Best Fitness", "Updated Fitness"]]

# Optionally, reset the index for a cleaner display
fitness_comparison_SA30Run.reset_index(drop=True, inplace=True)

# Display the comparison table
print("\n===== Best Fitness vs Updated Fitness per Day =====")
print(fitness_comparison_SA30Run)

# Save the DataFrame to an Excel file
fitness_comparison_SA30Run.to_excel("fitness_comparison_SA30Run.xlsx", index=False)

print(" Fitness comparison saved to 'fitness_comparison_SA30Runs.xlsx'")

import matplotlib.pyplot as plt
import numpy as np

# Compute Optimal Fitness once
optimal_fitness = sum(np.min(appliance_cost, axis=1))  # Minimum possible total cost



# Plot each run separately
plt.figure(figsize=(14, 7))
unique_runs = sa_results_df["Run"].unique()

for run_id in unique_runs:
    run_data = sa_results_df[sa_results_df["Run"] == run_id]
    plt.plot(run_data["Day"], run_data["Best Fitness"], label=f"Run {run_id}", marker='o', linestyle='-')
    # plt.plot(run_data["Day"], run_data["Updated Fitness"], label=f"Run {run_id}", marker='^', linestyle='--')

plt.axhline(y=optimal_fitness, color='red', linestyle='--', label="Optimal Fitness")

plt.xlabel("Day")
plt.ylabel("Fitness Value")
plt.title("Simulated Annealing: Best Fitness per Run vs. Optimal")
plt.legend(loc='upper right', bbox_to_anchor=(1.25, 1))
plt.grid(True)
plt.tight_layout()
plt.show()

sa_results = []
total_days = 86
runs =  1 # Run the simulation once for now
best_fitness_values = []
sa_max_iterations = 100
cooling_rate = 0.995
initial_temperature = 100000
# Initialize battery state and spillover for the first day
initial_battery_state = 0
battery_state_of_charge_sa = initial_battery_state
previous_day_spillover_sa = np.zeros((N, 2 * S))

deviations_per_day = []  # Store deviation per appliance per day
percentage_per_day = []  # Store daily percentage of appliances with a cost of 100

def calculate_deviation(actual_start_time, desired_start_time):
    return actual_start_time - desired_start_time

for rpt in range(1, runs + 1):
    print(f"\n===== Simulating Run {rpt} =====")
    battery_state_of_charge_sa = initial_battery_state
    previous_day_spillover_sa = np.zeros((N, 2 * S))

    for day in range(total_days):
        print(f"Simulating Day {day + 1}")

        current_predicted_generation = predicted_generation_train[day % len(predicted_generation_train)]
        next_predicted_generation = predicted_generation_train[(day + 1) % len(predicted_generation_train)]
        predicted_generation_48h = np.concatenate([current_predicted_generation, next_predicted_generation])

        appliance_cost = generate_cost_matrix(N, S, appliance_info)
        start_time_sa = time.time()

        best_solution_sa, best_fitness_sa = simulated_annealing_with_spillover(
            previous_day_spillover_sa,
            day,
            initial_temperature,
            cooling_rate,
            sa_max_iterations,
            battery_state_of_charge_sa,
            predicted_generation_48h,
            appliance_cost,appliance_consumption, active_durations, Q_min, Q_max, Z_min, Z_max, Θ, valid_slot_dict
        )

        end_time_sa = time.time()
        daily_deviation = []
        daily_costs = []
        appliances_with_100_cost = 0  # Initialize counter

        for n in range(N):
            desired_start_time = desired_start_times[n]
            actual_start_time = find_new_start_time(
                best_solution_sa[n, :S],
                best_solution_sa[n, S:],
                np.any(previous_day_spillover_sa)
            )
            deviation = calculate_deviation(actual_start_time, desired_start_time)
            appliance_total_cost = appliance_cost[n, actual_start_time]

            if appliance_total_cost == 100:
                appliances_with_100_cost += 1

            print(f"Appliance {n+1}: Desired Start = {desired_start_time}, Actual Start = {actual_start_time}, Deviation = {deviation}, Total Cost = {appliance_total_cost}")

            daily_deviation.append(deviation)
            daily_costs.append(appliance_total_cost)

        deviations_per_day.append(daily_deviation)
        percentage_per_day.append((appliances_with_100_cost / N) * 100)

        # Step 4: Initialize daily battery state
        battery_state_sa = np.zeros(48)

        # Step 5: Simulate hourly operations for the day
        for hour in range(48):
            generation = predicted_generation_48h[hour]
            required_consumption_sa = np.sum(best_solution_sa[:, hour] * appliance_consumption)
            available_energy_sa = battery_state_of_charge_sa if hour == 0 else battery_state_sa[hour - 1]
            actual_consumption_sa = min(required_consumption_sa, available_energy_sa)
            battery_state_sa[hour] = (battery_state_of_charge_sa + generation - actual_consumption_sa
                                      if hour == 0 else
                                      battery_state_sa[hour - 1] + generation - actual_consumption_sa)
            battery_state_sa[hour] = np.clip(battery_state_sa[hour], Z_min, Z_max)
            if actual_consumption_sa < required_consumption_sa:
                best_solution_sa[:, hour] = 0  # Disable usage if insufficient energy is available

        update_best_fitness_sa = fitness(best_solution_sa, appliance_cost, previous_day_spillover_sa, np.any(previous_day_spillover_sa), penalty=1000)
        sa_results.append([rpt, day + 1, "Simulated Annealing", best_fitness_sa, update_best_fitness_sa, end_time_sa - start_time_sa])
        display_schedule(best_solution_sa, day, previous_day_spillover_sa)
        visualize_schedule_with_spillover(best_solution_sa, day, appliance_names)
        print(f"Best Fitness: {best_fitness_sa}")
        print(f"Updated Fitness: {update_best_fitness_sa}")
        display_hourly_breakdown(day, predicted_generation_48h, best_solution_sa, appliance_consumption, battery_state_sa)
        previous_day_spillover_sa = best_solution_sa
        battery_state_of_charge_sa = battery_state_sa[23]

        plt.figure(figsize=(10, 6))
        plt.plot(range(24), predicted_generation_48h[:24], label='Predicted Generation (kWh)', color='blue')
        plt.plot(range(24), [np.sum(best_solution_sa[:, hour] * appliance_consumption) for hour in range(24)], label='Consumption (kWh)', color='green')
        plt.plot(range(24), battery_state_sa[:24], label='Battery State (kWh)', color='orange')
        plt.xlabel('Time (Hour of Day)')
        plt.ylabel('Energy (kWh)')
        plt.title(f'Day {day + 1} - Predicted Generation vs Consumption vs Battery State')
        plt.legend()
        plt.grid(True)
        plt.show()

    # === Stacked Bar Chart ===
    days = range(1, total_days + 1)
    percentage_not_cost_100 = [100 - p for p in percentage_per_day]

    plt.figure(figsize=(12, 6))
    plt.bar(days, percentage_per_day, color='salmon', edgecolor='black', label='Cost 100')
    plt.bar(days, percentage_not_cost_100, bottom=percentage_per_day, color='skyblue', edgecolor='black', label='Not Cost 100')


    # Labels & Titl
    plt.xlabel('Day')
    plt.ylabel('Percentage of Appliances')
    plt.title('Percentage of Appliances with Cost 100 vs Not Cost 100 Over Days')
    plt.xticks(range(1, total_days + 1, max(1, total_days // 10)))  # Adjust x-axis ticks dynamically
    plt.yticks(np.arange(0, 110, 10))  # Y-axis from 0 to 100 in steps of 10
    plt.legend()
    plt.grid(axis='y', linestyle='--', alpha=0.7)

    plt.show()



    sa_results_df = pd.DataFrame(sa_results, columns=["Run", "Day", "Method", "Best Fitness", "Updated Fitness", "Execution Time (s)"])
    deviations_df = pd.DataFrame(deviations_per_day, columns=[f"Appliance {i+1}" for i in range(N)])

# Group SA results by 'Run' and calculate statistics
sa_summary = sa_results_df.groupby("Run").agg({
    "Day": "count",
    "Best Fitness": ["mean", "std", "min", "max", "median"],
    "Updated Fitness" : ["mean", "std", "min", "max", "median"],
    "Execution Time (s)": "sum"
})

# Rename columns for clarity
sa_summary.columns = [
    "Days Count",
    "Best Fitness Mean", "Best Fitness Std", "Best Fitness Min", "Best Fitness Max", "Best Fitness Median",
    "Updated Fitness Mean", "Updated Fitness Std", "Updated Fitness Min", "Updated Fitness Max", "Updated Fitness Median",
    "Total Execution Time (s)"
]
sa_summary.reset_index(inplace=True)



print("\n=====  Simulated Annealing (SA) Grouped Summary by Run =====")
print(sa_summary)

# Extract fitness values from SA results
best_fitness_sa = sa_results_df["Best Fitness"].tolist()
updated_fitness_sa = sa_results_df["Updated Fitness"].tolist()

# Compute Optimal Fitness (Sum of minimum costs per appliance)
optimal_fitness = sum(np.min(appliance_cost, axis=1))  # Smallest cost per appliance

# Generate Plot
plt.figure(figsize=(12, 6))
days = range(1, len(best_fitness_sa) + 1)


# Plot SA results
plt.plot(days, best_fitness_sa, label="Best Fitness (SA)", marker="d", linestyle="-", color="green")
#plt.plot(days, updated_fitness_sa, label="Updated Fitness (SA)", marker="^", linestyle="--", color="lime")

# Plot Optimal Fitness as a horizontal line
plt.axhline(y=optimal_fitness, color="red", linestyle="--", label="Optimal Fitness")

# Labels and Title
plt.xlabel("Day")
plt.ylabel("Fitness Value")
plt.title("Comparison of SA Fitness vs. Optimal Fitness Over Days")
plt.legend()
plt.grid(True)

# Show plot
plt.show()

sa_results = []
total_days = 86
runs =  30 # Run the simulation once for now
best_fitness_values = []
sa_max_iterations = 100
cooling_rate = 0.995
initial_temperature = 100000
# Initialize battery state and spillover for the first day
initial_battery_state = 0
battery_state_of_charge_sa = initial_battery_state
previous_day_spillover_sa = np.zeros((N, 2 * S))

deviations_per_day = []  # Store deviation per appliance per day
percentage_per_day = []  # Store daily percentage of appliances with a cost of 100

def calculate_deviation(actual_start_time, desired_start_time):
    return actual_start_time - desired_start_time

for rpt in range(1, runs + 1):
    print(f"\n===== Simulating Run {rpt} =====")
    battery_state_of_charge_sa = initial_battery_state
    previous_day_spillover_sa = np.zeros((N, 2 * S))

    for day in range(total_days):
        print(f"Simulating Day {day + 1}")

        current_predicted_generation = predicted_generation_train[day % len(predicted_generation_train)]
        next_predicted_generation = predicted_generation_train[(day + 1) % len(predicted_generation_train)]
        predicted_generation_48h = np.concatenate([current_predicted_generation, next_predicted_generation])

        appliance_cost = generate_cost_matrix(N, S, appliance_info)
        start_time_sa = time.time()

        best_solution_sa, best_fitness_sa = simulated_annealing_with_spillover(
            previous_day_spillover_sa,
            day,
            initial_temperature,
            cooling_rate,
            sa_max_iterations,
            battery_state_of_charge_sa,
            predicted_generation_48h,
            appliance_cost,appliance_consumption, active_durations, Q_min, Q_max, Z_min, Z_max, Θ, valid_slot_dict
        )

        end_time_sa = time.time()
        daily_deviation = []
        daily_costs = []
        appliances_with_100_cost = 0  # Initialize counter

        for n in range(N):
            desired_start_time = desired_start_times[n]
            actual_start_time = find_new_start_time(
                best_solution_sa[n, :S],
                best_solution_sa[n, S:],
                np.any(previous_day_spillover_sa)
            )
            deviation = calculate_deviation(actual_start_time, desired_start_time)
            appliance_total_cost = appliance_cost[n, actual_start_time]

            if appliance_total_cost == 100:
                appliances_with_100_cost += 1

            print(f"Appliance {n+1}: Desired Start = {desired_start_time}, Actual Start = {actual_start_time}, Deviation = {deviation}, Total Cost = {appliance_total_cost}")

            daily_deviation.append(deviation)
            daily_costs.append(appliance_total_cost)

        deviations_per_day.append(daily_deviation)
        percentage_per_day.append((appliances_with_100_cost / N) * 100)

        # Step 4: Initialize daily battery state
        battery_state_sa = np.zeros(48)

        # Step 5: Simulate hourly operations for the day
        for hour in range(48):
            generation = predicted_generation_48h[hour]
            required_consumption_sa = np.sum(best_solution_sa[:, hour] * appliance_consumption)
            available_energy_sa = battery_state_of_charge_sa if hour == 0 else battery_state_sa[hour - 1]
            actual_consumption_sa = min(required_consumption_sa, available_energy_sa)
            battery_state_sa[hour] = (battery_state_of_charge_sa + generation - actual_consumption_sa
                                      if hour == 0 else
                                      battery_state_sa[hour - 1] + generation - actual_consumption_sa)
            battery_state_sa[hour] = np.clip(battery_state_sa[hour], Z_min, Z_max)
            if actual_consumption_sa < required_consumption_sa:
                best_solution_sa[:, hour] = 0  # Disable usage if insufficient energy is available

        update_best_fitness_sa = fitness(best_solution_sa, appliance_cost, previous_day_spillover_sa, np.any(previous_day_spillover_sa), penalty=1000)
        sa_results.append([rpt, day + 1, "Simulated Annealing", best_fitness_sa, update_best_fitness_sa, end_time_sa - start_time_sa])
        display_schedule(best_solution_sa, day, previous_day_spillover_sa)
        visualize_schedule_with_spillover(best_solution_sa, day, appliance_names)
        print(f"Best Fitness: {best_fitness_sa}")
        print(f"Updated Fitness: {update_best_fitness_sa}")
        display_hourly_breakdown(day, predicted_generation_48h, best_solution_sa, appliance_consumption, battery_state_sa)
        previous_day_spillover_sa = best_solution_sa
        battery_state_of_charge_sa = battery_state_sa[23]

        plt.figure(figsize=(10, 6))
        plt.plot(range(24), predicted_generation_48h[:24], label='Predicted Generation (kWh)', color='blue')
        plt.plot(range(24), [np.sum(best_solution_sa[:, hour] * appliance_consumption) for hour in range(24)], label='Consumption (kWh)', color='green')
        plt.plot(range(24), battery_state_sa[:24], label='Battery State (kWh)', color='orange')
        plt.xlabel('Time (Hour of Day)')
        plt.ylabel('Energy (kWh)')
        plt.title(f'Day {day + 1} - Predicted Generation vs Consumption vs Battery State')
        plt.legend()
        plt.grid(True)
        plt.show()

    # === Stacked Bar Chart ===
    #days = range(1, total_days + 1)
    days = list(range(1, len(percentage_per_day) + 1))
    percentage_not_cost_100 = [100 - p for p in percentage_per_day]

    plt.figure(figsize=(12, 6))
    plt.bar(days, percentage_per_day, color='salmon', edgecolor='black', label='Cost 100')
    plt.bar(days, percentage_not_cost_100, bottom=percentage_per_day, color='skyblue', edgecolor='black', label='Not Cost 100')


    # Labels & Titl
    plt.xlabel('Day')
    plt.ylabel('Percentage of Appliances')
    plt.title('Percentage of Appliances with Cost 100 vs Not Cost 100 Over Days')
    plt.xticks(range(1, total_days + 1, max(1, total_days // 10)))  # Adjust x-axis ticks dynamically
    plt.yticks(np.arange(0, 110, 10))  # Y-axis from 0 to 100 in steps of 10
    plt.legend()
    plt.grid(axis='y', linestyle='--', alpha=0.7)

    plt.show()



    sa_results_df = pd.DataFrame(sa_results, columns=["Run", "Day", "Method", "Best Fitness", "Updated Fitness", "Execution Time (s)"])
    deviations_df = pd.DataFrame(deviations_per_day, columns=[f"Appliance {i+1}" for i in range(N)])

# Group SA results by 'Run' and calculate statistics
sa_summary = sa_results_df.groupby("Run").agg({
    "Day": "count",
    "Best Fitness": ["mean", "std", "min", "max", "median"],
    "Updated Fitness" : ["mean", "std", "min", "max", "median"],
    "Execution Time (s)": "sum"
})

# Rename columns for clarity
sa_summary.columns = [
    "Days Count",
    "Best Fitness Mean", "Best Fitness Std", "Best Fitness Min", "Best Fitness Max", "Best Fitness Median",
    "Updated Fitness Mean", "Updated Fitness Std", "Updated Fitness Min", "Updated Fitness Max", "Updated Fitness Median",
    "Total Execution Time (s)"
]
sa_summary.reset_index(inplace=True)



print("\n=====  Simulated Annealing (SA) Grouped Summary by Run =====")
print(sa_summary)

# Extract relevant columns (Run, Day, Best Fitness, and Updated Fitness)
fitness_comparison_SA30Run = sa_results_df[["Run", "Day", "Best Fitness", "Updated Fitness"]]

# Optionally, reset the index for a cleaner display
fitness_comparison_SA30Run.reset_index(drop=True, inplace=True)

# Display the comparison table
print("\n===== Best Fitness vs Updated Fitness per Day =====")
print(fitness_comparison_SA30Run)

# Save the DataFrame to an Excel file
fitness_comparison_SA30Run.to_excel("fitness_comparison_SA30Run.xlsx", index=False)

print(" Fitness comparison saved to 'fitness_comparison_SA30Runs.xlsx'")

# Group SA results by 'Run' and calculate statistics
sa_summary = sa_results_df.groupby("Run").agg({
    "Day": "count",
    "Best Fitness": ["mean", "std", "min", "max", "median"],
    "Updated Fitness" : ["mean", "std", "min", "max", "median"],
    "Execution Time (s)": "sum"
})

# Rename columns for clarity
sa_summary.columns = [
    "Days Count",
    "Best Fitness Mean", "Best Fitness Std", "Best Fitness Min", "Best Fitness Max", "Best Fitness Median",
    "Updated Fitness Mean", "Updated Fitness Std", "Updated Fitness Min", "Updated Fitness Max", "Updated Fitness Median",
    "Total Execution Time (s)"
]
sa_summary.reset_index(inplace=True)



print("\n=====  Simulated Annealing (SA) Grouped Summary by Run =====")
print(sa_summary)
# Extract relevant columns (Run, Day, Best Fitness, and Updated Fitness)
fitness_comparison_SA30Run = sa_results_df[["Run", "Day", "Best Fitness", "Updated Fitness"]]

# Optionally, reset the index for a cleaner display
fitness_comparison_SA30Run.reset_index(drop=True, inplace=True)

# Display the comparison table
print("\n===== Best Fitness vs Updated Fitness per Day =====")
print(fitness_comparison_SA30Run)

# Save the DataFrame to an Excel file
fitness_comparison_SA30Run.to_excel("fitness_comparison_SA30Run.xlsx", index=False)

print(" Fitness comparison saved to 'fitness_comparison_SA30Runs.xlsx'")

import matplotlib.pyplot as plt
import numpy as np

# Compute Optimal Fitness once
optimal_fitness = sum(np.min(appliance_cost, axis=1))  # Minimum possible total cost



# Plot each run separately
plt.figure(figsize=(14, 7))
unique_runs = sa_results_df["Run"].unique()

for run_id in unique_runs:
    run_data = sa_results_df[sa_results_df["Run"] == run_id]
    plt.plot(run_data["Day"], run_data["Best Fitness"], label=f"Run {run_id}", marker='o', linestyle='-')
    # plt.plot(run_data["Day"], run_data["Updated Fitness"], label=f"Run {run_id}", marker='^', linestyle='--')

plt.axhline(y=optimal_fitness, color='red', linestyle='--', label="Optimal Fitness")

plt.xlabel("Day")
plt.ylabel("Fitness Value")
plt.title("Simulated Annealing: Best Fitness per Run vs. Optimal")
plt.legend(loc='upper right', bbox_to_anchor=(1.25, 1))
plt.grid(True)
plt.tight_layout()
plt.show()



# update geometric cooling

def simulated_annealing_with_spillover(previous_day_spillover, day, initial_temperature, cooling_rate, max_iterations,
                                       battery_state_of_charge, predicted_generation, appliance_cost, appliance_consumption,
                                       active_durations, Q_min, Q_max, Z_min, Z_max, Θ):
    S = 24  # Total slots for scheduling (24 hours + 24 spillover slots)

    if day == 0:
        current_solution = generate_random_solution_with_constraints(battery_state_of_charge, predicted_generation)
    else:
        current_solution = prepare_next_day_initial_solution(previous_day_spillover, day)

    is_spillover_day = np.any(previous_day_spillover)
    spillover_slots = np.copy(previous_day_spillover)

    current_fitness = fitness(current_solution, appliance_cost, spillover_slots, is_spillover_day)
    best_solution = np.copy(current_solution)
    best_fitness = current_fitness
    temperature = initial_temperature

    appliances = list(range(len(appliance_cost)))

    # List to store fitness for plotting
    fitness_progression = [current_fitness]

    print(f"Initial Fitness: {current_fitness:.4f}, Initial Temperature: {temperature:.4f}")

    for iteration in range(max_iterations):
        print(f"Iteration {iteration + 1}, Current Temperature: {temperature:.4f}")
        np.random.shuffle(appliances)  # Randomize appliance order

        for appliance_to_modify in appliances:
            new_solution = np.copy(current_solution)
            duration = active_durations[appliance_to_modify]

            start_slot = np.random.randint(0, S)
            end_slot = start_slot + duration

            # Reset schedule for this appliance
            new_solution[appliance_to_modify, :] = 0

            # Assign 1's to the selected time slots
            if end_slot <= S:
                new_solution[appliance_to_modify, start_slot:end_slot] = 1
            else:
                new_solution[appliance_to_modify, start_slot:S] = 1
                spillover_duration = end_slot - S
                new_solution[appliance_to_modify, S:S + spillover_duration] = 1  # Fill the next day's slots

            # Strict constraint checking
            valid_solution = True
            battery_state = float(battery_state_of_charge)
            for hour in range(2 * S):
                generation = np.clip(predicted_generation[hour], Q_min, Q_max)
                demand = np.sum(new_solution[:, hour] * appliance_consumption)

                if demand > Θ or demand > battery_state:
                    valid_solution = False
                    break

                battery_state += generation - demand
                if battery_state < Z_min or battery_state > Z_max:
                    valid_solution = False
                    break

            # Evaluate only valid solutions
            if valid_solution:
                new_fitness = fitness(new_solution, appliance_cost, spillover_slots, is_spillover_day)

                if new_fitness < best_fitness:
                    best_solution = np.copy(new_solution)
                    best_fitness = new_fitness

                acceptance_prob = np.exp((current_fitness - new_fitness) / temperature)
                if new_fitness < current_fitness or np.random.rand() < acceptance_prob:
                    current_solution = np.copy(new_solution)
                    current_fitness = new_fitness

                #  Added detailed logging here:
                print(f"  Appliance {appliance_to_modify}: curr_fitness={current_fitness:.4f}, new_fitness={new_fitness:.4f}, best_fitness={best_fitness:.4f}, T={temperature:.4f}")

                break  # Stop retry loop if valid solution found

        # Record fitness for plotting
        fitness_progression.append(best_fitness)

        # Cooling schedule
       # temperature *= (1 / (1 + cooling_rate * (iteration + 1)))
        temperature *= cooling_rate  # geometric cooling
        # if temperature < 1e-3:
            # print("Terminating early due to low temperature.")
            #break

    # Plot the fitness progression
    plt.figure(figsize=(10, 6))
    plt.plot(fitness_progression, label="Best Fitness")
    plt.xlabel('Iteration')
    plt.ylabel('Fitness')
    plt.title('Fitness Progression Over Iterations')
    plt.grid(True)
    plt.legend()
    plt.show()

    return best_solution, best_fitness

"""hyperparameter tuning for Simulated Annealing (SA)"""

# Define hyperparameter to tune
temperature_options = [10, 100, 1000000]
cooling_rate_options = [0.8, 0.95, 0.99]
iteration_options = [10, 100, 1000]

# Store all results
tuning_results = []

for initial_temperature in temperature_options:
    for cooling_rate in cooling_rate_options:
        for sa_max_iterations in iteration_options:

            print(f"\n=== Tuning: T0={initial_temperature}, cooling={cooling_rate}, iters={sa_max_iterations} ===")
            sa_results = []
            deviations_per_day = []
            percentage_per_day = []

            for rpt in range(1, runs + 1):
                print(f"\n===== Simulating Run {rpt} =====")
                battery_state_of_charge_sa = initial_battery_state
                previous_day_spillover_sa = np.zeros((N, 2 * S))

                for day in range(total_days):
                    print(f"Simulating Day {day + 1}")

                    current_predicted_generation = predicted_generation_train[day % len(predicted_generation_train)]
                    next_predicted_generation = predicted_generation_train[(day + 1) % len(predicted_generation_train)]
                    predicted_generation_48h = np.concatenate([current_predicted_generation, next_predicted_generation])

                    appliance_cost = generate_cost_matrix(N, S, appliance_info)
                    start_time_sa = time.time()

                    best_solution_sa, best_fitness_sa = simulated_annealing_with_spillover(previous_day_spillover_sa,
                                                                                           day, initial_temperature, cooling_rate,
                                                                                           sa_max_iterations, battery_state_of_charge_sa,
                                                                                           predicted_generation_48h, appliance_cost,appliance_consumption,
                                                                                           active_durations, Q_min, Q_max, Z_min, Z_max, Θ)


                    end_time_sa = time.time()

                    daily_deviation = []
                    appliances_with_100_cost = 0

                    for n in range(N):
                        desired_start_time = desired_start_times[n]
                        actual_start_time = find_new_start_time(
                            best_solution_sa[n, :S],
                            best_solution_sa[n, S:],
                            np.any(previous_day_spillover_sa)
                        )
                        deviation = calculate_deviation(actual_start_time, desired_start_time)
                        appliance_total_cost = appliance_cost[n, actual_start_time]

                        if appliance_total_cost == 100:
                            appliances_with_100_cost += 1

                        daily_deviation.append(deviation)

                    deviations_per_day.append(daily_deviation)
                    percentage_per_day.append((appliances_with_100_cost / N) * 100)

                    battery_state_sa = np.zeros(48)

                    for hour in range(48):
                        generation = predicted_generation_48h[hour]
                        required_consumption_sa = np.sum(best_solution_sa[:, hour] * appliance_consumption)
                        available_energy_sa = battery_state_of_charge_sa if hour == 0 else battery_state_sa[hour - 1]

                        actual_consumption_sa = min(required_consumption_sa, available_energy_sa)
                        battery_state_sa[hour] = (
                            battery_state_of_charge_sa + generation - actual_consumption_sa
                            if hour == 0 else
                            battery_state_sa[hour - 1] + generation - actual_consumption_sa
                        )
                        battery_state_sa[hour] = np.clip(battery_state_sa[hour], Z_min, Z_max)

                        if actual_consumption_sa < required_consumption_sa:
                            affected_appliances = np.where(best_solution_sa[:, hour] == 1)[0]
                            for app in affected_appliances:
                                best_solution_sa[app, hour] = 0

                    update_best_fitness_sa = fitness(best_solution_sa, appliance_cost, previous_day_spillover_sa, np.any(previous_day_spillover_sa), penalty=1000)

                    sa_results.append([rpt, day + 1, "Simulated Annealing", best_fitness_sa, update_best_fitness_sa, end_time_sa - start_time_sa])

                    display_schedule(best_solution_sa, day, previous_day_spillover_sa)
                    visualize_schedule_with_spillover(best_solution_sa, day, appliance_names)

                    print(f"Best Fitness: {best_fitness_sa}")
                    print(f"Updated Fitness: {update_best_fitness_sa}")

                    display_hourly_breakdown(day, predicted_generation_48h, best_solution_sa, appliance_consumption, battery_state_sa)

                    previous_day_spillover_sa = best_solution_sa
                    battery_state_of_charge_sa = battery_state_sa[23]

                    # Generation vs Consumption vs Battery visualization
                    plt.figure(figsize=(10, 6))
                    plt.plot(range(24), predicted_generation_48h[:24], label='Predicted Generation (kWh)', color='blue')
                    plt.plot(range(24), [np.sum(best_solution_sa[:, hour] * appliance_consumption) for hour in range(24)], label='Consumption (kWh)', color='green')
                    plt.plot(range(24), battery_state_sa[:24], label='Battery State (kWh)', color='orange')
                    plt.xlabel('Time (Hour of Day)')
                    plt.ylabel('Energy (kWh)')
                    plt.title(f'Day {day + 1} - Predicted Generation vs Consumption vs Battery State')
                    plt.legend()
                    plt.grid(True)
                    plt.show()

                # Daily cost bar chart after all days
                days = range(1, total_days + 1)
                percentage_not_cost_100 = [100 - p for p in percentage_per_day]

                plt.figure(figsize=(12, 6))
                plt.bar(days, percentage_per_day, color='salmon', edgecolor='black', label='Cost 100')
                plt.bar(days, percentage_not_cost_100, bottom=percentage_per_day, color='skyblue', edgecolor='black', label='Not Cost 100')
                plt.xlabel('Day')
                plt.ylabel('Percentage of Appliances')
                plt.title('Percentage of Appliances with Cost 100 vs Not Cost 100 Over Days')
                plt.xticks(range(1, total_days + 1, max(1, total_days // 10)))
                plt.yticks(np.arange(0, 110, 10))
                plt.legend()
                plt.grid(axis='y', linestyle='--', alpha=0.7)
                plt.show()

                sa_results_df = pd.DataFrame(sa_results, columns=["Run", "Day", "Method", "Best Fitness", "Updated Fitness", "Execution Time (s)"])
                deviations_df = pd.DataFrame(deviations_per_day, columns=[f"Appliance {i+1}" for i in range(N)])

                # Log results for tuning
                for day_idx, row in enumerate(sa_results):
                    tuning_results.append({
                        'initial_temperature': initial_temperature,
                        'cooling_rate': cooling_rate,
                        'sa_max_iterations': sa_max_iterations,
                        'run': rpt,
                        'day': row[1],
                        'best_fitness': row[3],
                        'updated_fitness': row[4],
                        'execution_time': row[5]
                    })

columns = ["Run ID", "Day", "Temperature", "Cooling Rate", "Max Iterations", "Best Fitness", "Updated Fitness", "Execution Time (s)"]
tuning_df = pd.DataFrame(tuning_results, columns=columns)
tuning_df.to_excel("sa_hyperparameter_tuning_results.xlsx", index=False)

print(tuning_df.columns)

tuning_df = pd.read_excel("sa_hyperparameter_tuning_results.xlsx")

import matplotlib.pyplot as plt
# Compute Optimal Fitness (Sum of minimum costs per appliance)
optimal_fitness = sum(np.min(appliance_cost, axis=1))  # Smallest cost per applianc
# Unique tuning runs
unique_runs = tuning_df["Run ID"].unique()

plt.figure(figsize=(14, 7))

# Plot each run
for run_id in unique_runs:
    run_data = tuning_df[tuning_df["Run ID"] == run_id]
    plt.plot(run_data["Day"], run_data["Best Fitness"], label=f"{run_id}", marker='o', linestyle='-')

# Plot Optimal Fitness
plt.axhline(y=optimal_fitness, color='red', linestyle='--', label="Optimal Fitness")

# Formatting
plt.xlabel("Day")
plt.ylabel("Fitness Value")
plt.title("SA Hyperparameter Tuning: Best Fitness vs. Optimal Fitness")
plt.legend(loc='upper right', bbox_to_anchor=(1.25, 1))
plt.grid(True)
plt.tight_layout()

plt.show()

for run_id in unique_runs:
    run_data = tuning_df[tuning_df["Run ID"] == run_id]
    temp = run_data["Temperature"].iloc[0]
    cool = run_data["Cooling Rate"].iloc[0]
    iter_ = run_data["Max Iterations"].iloc[0]
    label = f"T={temp}, CR={cool}, I={iter_}"
    plt.plot(run_data["Day"], run_data["Best Fitness"], label=label, marker='o', linestyle='-')